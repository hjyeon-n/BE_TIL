# 개발과 설계 원칙 🔥

## SOLID✅

SOLID 원칙이란 객체지향 설계에서 지켜줘야 할 5개의 원칙( **S**RP, **O**CP, **L**SP, **D**IP, **I**SP )을 말한다.

<br>

### SRP (단일책임의 원칙: Single Responsibility Principle) 🐱

**객체는 단 하나의 책임만 가져야 한다는 원칙**을 말한다. 이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 함을 의미한다. 사칙연산 함수를 가지고 있는 계산 클래스가 있다고 치자. 이 상태의 계산 클래스는 오직 사칙연산 기능만을 책임진다. 이 클래스를 수정한다고 한다면 그 이유는 사직연산 함수와 관련된 문제일 뿐이다.

객체지향적으로 설계할 때는 **응집도를 높게, 결합도는 낮게** 설계하는 것이 좋다.

#### 응집도와 결합도?

- 응집도

  : 한 프로그램의 요소가 얼마나 뭉쳐있는지, 즉 구성 요소들 사이의 응집력을 말합니다.

- 결합도

  : 프로그램 구성 요소들 사이가 얼마나 의존적인지를 말합니다.

한 객체에 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다. 즉, 객체마다 책임을 제대로 나누지 않는다면 시스템은 매우 복잡해진다. SRP에 따른 설계를 하면 **응집도는 높게, 결합도는 낮게 설계**할 수 있게 된다. 

<br>

### OCP (개방폐쇄의 원칙: Open Close Principle) 😺

**기존의 코드를 변경하지 않으면서( closed ), 기능을 추가할 수 있도록( open ) 설계가 되어야 한다는 원칙**을 말한다. 즉, 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다는 의미를 갖는다. 쉽게 설명하면 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻으로 이해하면 된다!

#### 그러면 어떻게 해야 해⁉

OCP를 만족하는 설계가 되려면, **캡슐화**를 통해 여러 객체에서 사용하는 같은 기능을 인터페이스에 정의하는 방법이 있다.

![image](https://user-images.githubusercontent.com/62419307/90494099-1a348580-e17e-11ea-85bd-885a9430691e.png)

<br>

### LSP (리스코브 치환의 원칙: The Liskov Substitution Principle) 😸

**자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙**이다. 즉, 자식 클래스는 언제나 부모 클래스의 역할을 대체할 수 있어야 한다는 것을 말하며, 부모 클래스와 자식 클래스의 행위가 일관됨을 의미한다.

자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드 되지 않도록 하면 된다. 즉, **자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행**하도록 해야 LSP를 만족하게 된다.

#### 어떻게 적용해⁉

1. 만약 두 개체가 똑 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둔다.
2. 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현한다. (인터페이스 상속)
3. 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만든다.
4. 만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.

<br>

### ISP (인터페이스 분리의 원칙: Interface Segregation Principle) 😽

**자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 설계 원칙**이다. 즉, 하나의 거대한 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다는 것을 의미한다. **SRP는 객체의 단일 책임을 뜻한다면, ISP는 인터페이스의 단일 책임**을 의미한다고 보면 된다.

<br>

#### 어떻게 적용해⁉

예를 들어, 핸드폰( Phone )에는 전화( call ), 문자( sms ), 알람( alarm ), 계산기( calculator ) 등의 기능이 있다. 3G폰과 현재 스마트폰은 Phone의 기능들을 사용하므로, call, sms, alarm, calculator 기능이 정의된 Phone 인터페이스를 정의하려고 한다.

![image](https://user-images.githubusercontent.com/62419307/90498611-806fd700-e183-11ea-9591-3eae3b820866.png)

그러나 ISP를 만족하려면 Phone 인터페이스에 call(), sms(), alarm(), calculator() 함수를 모두 정의하는 것보다, Call, Sms, Alarm, Calculator 인터페이스를 각각 정의하여 3G폰과 스마트폰 클래스에서 4개의 인터페이스를 구현하도록 설계해야 한다.

![image](https://user-images.githubusercontent.com/62419307/90498718-9da4a580-e183-11ea-96a3-c2ce0e8f53f2.png)

이렇게 설계를 하면, 각 인터페이스의 메서드들이 서로 영향을 미치지 않게 된다. 즉, 자신이 사용하지 않는 메서드에 대해서 영향력이 줄어들게 된다.

<br>

### DIP (의존성역전의 원칙: Dependency Inversion Principle) 😼

객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, **이때** **객체들은** **나름대로의 원칙을 갖고 정보를 주고 받아야 한다는 설계 원칙**이다. 여기서 나름대로의 원칙이란, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 것을 의미한다. 일반적으로 인터페이스를 활용하면 이 원칙을 준수할 수 있게 된다. 

![image](https://user-images.githubusercontent.com/62419307/90499123-1c014780-e184-11ea-8ac6-4daf3d668039.png)

Client 객체는 Cat, Dog, Bird의 crying() 메서드에 직접 접근하지 않고, Animal 인터페이스의 crying() 메서드를 호출함으로써 DIP를 만족할 수 있다.

<br>

[참고1](https://victorydntmd.tistory.com/291)

[참고2](http://www.nextree.co.kr/p6960/)

[참고3]([https://medium.com/@hckcksrl/solid-%EC%9B%90%EC%B9%99-182f04d0d2b](https://medium.com/@hckcksrl/solid-원칙-182f04d0d2b))

[참고4](https://wikidocs.net/492)

