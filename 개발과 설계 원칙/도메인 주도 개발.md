# 도메인 주도 개발 (Domain Driven Development)

도메인 기반 디자인은 소프트웨어 코드의 구조와 언어가 비즈니스 도메인과 일치해야한다는 개념

### 도메인 주도 개발(DDD)는 왜 도입됐어? 👀

> 기존의 개발

- 데이터에 종속적인 애플리케이션
- 모델링과 개발과의 불일치 발생

<br>

> 도메인 주도 설계

이런 불일치를 해소하기 위한 노력 중 하나가 바로 DDD‼

- 공통의 언어(**유비쿼터스 언어**)를 사용하여 도메인과 구현을 충분히 만족하는 모델을 만든다.
- **유비쿼터스 언어**를 사용하여 **용어사전**을 만든다. (예) 헌터 | hunter | 보물을 찾는 사냥꾼
- '**설계**'와 '**구현**'은 계속된 수정 과정을 거친다. (반복 작업)

**유비쿼터스 언어가 뭐지? 🙋‍♀️**

도메인 어휘를 이해관계자들이 공통적으로 의미를 이해할 수 있도록 정의하는 것

<br>

### 효과적인 모델링

1. 사용자와 개발자는 동일한 언어로 이야기하는가?
2.  해당 언어가 애플리케이션에서 수행해야 할 내용에 관한 논의를 이끌어갈 만큼 풍성한가?

<br>

### 도메인

1. 일반적인 요구사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역
2. 소프트웨어로 해결하고자 하는 문제 영역

🗨 (예) 광고회사의 광고와 관련된 지식 = 도메인

<br>

### 도메인 모델

1. 특정 도메인을 개념적으로 표현한 것
2. 도메인 모델을 사용하면 여러 관계자들(개발자, 기획자, 사용자 등)이 동일한 모습으로 도메인을 이해하고, 도메인 지식을 공유하는 데 도움이 된다.
3. 모델의 각 구성 요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다.

🗨 (예) 쿠팡에서 상품을 주문할 때 필요한 것: 고객의 **주문서 모델**, 상품 정보의 **상품 모델**

<br>

### 도메인 주도 설계 아키텍처

![image](https://user-images.githubusercontent.com/62419307/90731882-40386200-e305-11ea-89f1-13277b617018.png)

핵심 로직(비즈니스 로직)은 도메인 모델에 담아서 사용한다.

<br>

### 도메인 모델의 네 개의 영역

![image](https://user-images.githubusercontent.com/62419307/90732061-7c6bc280-e305-11ea-8809-2929c2a09ac0.png)

아래로 내려갈수록 의존성이 강해진다.

 <br>

- **PRESENTATION LAYER**: 표현 영역 또는 UI 영역. 사용자의 요청을 받아 응용 영역에 전달하고, 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. (Controller 영역, DispatcherServlet에게 요청과 응답을 전달하는 역할)
- **APPLICATION LAYER**: 응용 영역. 시스템이 사용자에게 제공해야 할 기능을 구현한다. (Service 영역)

- **DOMAIN LAYER**: 도메인 영역. 도메인 모델을 구현한다. (이름, 주소, 상품, 주문서 등)

- **INFRASTRUCTURE LAYER** : 구현 기술에 대한 것을 다룬다. (외부 API, 데이터베이스, 외부 라이브러리 사용 등)

 <br>

#### PRESENTATION LAYER (표현 영역)

1. 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어
2. 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
3. 사용자의 세션을 관리한다.

 <br>

#### APPLICATION LAYER (응용영역)

1. 사용자의 요청을 처리하기 위해 **리포지터리**로부터 **도메인 객체**를 구하고, 도메인 객체를 **사용**한다.
2. 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
3. 도메인 객체 간의 실행 흐름을 제어
4. 트랜잭션 처리
5. 도메인 영역에서 발생시킨 **이벤트**를 처리

**트랜잭션이 뭐지? 🙋‍♀️**

데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위.

🗨 (예) 게시판 사용자가 게시글을 작성하고, 올리기 버튼을 누른다  → 그 후에 다시 게시판에 돌아왔을때, 자신의 글이 포함되어 업데이트된 게시판을 보게 된다

 <br>

### 도메인 주도 설계 기본 요소

> Entity와 Value

1. 도출한 모델은 크게 엔티티와 밸류로 구분

2. 데이터와 함께 도메인 기능을 제공한다.

![image](https://user-images.githubusercontent.com/62419307/90733121-1122f000-e307-11ea-974f-2d2ddf060612.png)

#### Entity

- **식별자**를 갖는다.
- 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.

식별자? 식별자는 어떻게 생성해? 🙋‍♀️

1. 특정 규칙에 따라 생성 
2. UUID 사용
3. 값을 직접 입력 
4. 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)

<br>

#### Value Object

1. value 타입은 불변을 원칙으로 한다.
2. 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 value 타입을 이용
3. 시스템이 성숙함에 따라 데이터 값을 객체로 대체
4. value 객체의 값을 변경하는 방법은 새로운 value 객체를 할당하는 것뿐이다.
5. 식별자가 존재하지 않는다.

<br>

#### Aggregate

1. 관련 객체를 하나로 묶은 군집
2. 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.
3. 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
4. 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
5. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
6. 대부분의 애그리거트는 한개의 엔티티 객체를 가지며, 두 개 이상의 앤티티로 구성되는 애그리거트는 드물게 존재한다.
7. 각 애그리거트는 자기 자신을 관리할 뿐, 다른 애그리거트는 관리하지 않는다.

🗨 (예) 주문 애그리거트는 배송지 변경, 주문 상품 변경 등 자신은 관리하지만 회원 비밀번호 변경, 상품 가격 변경 등은 하지 않는다.

<br>

[참고](https://ppiyo5.tistory.com/21#recentEntries)