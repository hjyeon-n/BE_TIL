# 구조 패턴(Structural Pattern)🤗

- 프로그램 구조에 관련된 패턴들
- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들

<br>

#### 🖐 여기서 잠깐❗

코드로는 따로 정리된 게 없으니 **참고자료 출처에서 꼭 확인해 볼 것**🔥

<br>

### 어댑터 패턴 🍉

어댑터 패턴은 **서로 다르게 구현된 인터페이스를 사용하려는 다른 인터페이스로 변환**하는 것을 말한다. 즉, 두 개의 인터페이스가 서로 다른 경우에 한 쪽의 인터페이스에 맞춰서 하나로 만들어 사용하게 하는 구조다. 

![image](https://user-images.githubusercontent.com/62419307/90539933-723dad00-e1bb-11ea-96a7-4e6cd35732d3.png)

어댑터 패턴은 2가지로 나뉜다.

- 객체 어댑터 패턴: 객체를 내부에 선언해 사용한다.
- 클래스 어댑터 패턴: 클래스 어댑터 패턴은 다중 상속이 필요한데, 자바에서는 클래스의 다중 상속을 지원하지 않는다. 따라서 클라이언트가 인터페이스가 아닌 일부 구현이 필요한 추상클래스라면 자바에서는 클래스어댑터 구현에 제약이 따른다.

<br>

### 브리지 패턴 (Bridge Pattern) 🥝

브리지 패턴이란 **구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴**이다. 브리지 패턴은 말그대로 다리 역할을 하는데, 기능 클래스 계층과 구현 클래스 계층을 서로 연결하는 패턴이다.

- 기능 클래스 계층

  : 상위 클래스 A를 상속 받는 하위 클래스 B에 새로운 기능을 추가하는 계층을 말한다.

- 구현 클래스 계층

  : 인터페이스 A를 구현한 객체 B가 존재할 때 이를 구현 클래스 계층이라고 한다.

<br>

### 컴포지트 패턴 (Composite pattern) 🍐

컴포지트 패턴이란 **객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴**으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 한다. 

1. 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들수 있다.
2.  클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체(composite)를 똑같은 방법으로 다룰 수 있다.

<br>

### 데코레이터 패턴 (Decorator pattern) 🍒

데코레이터 패턴은 객체에게 추가적인 요건을 동적으로 첨가할 수 있는 것을 말한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있다. 데코레이터 말 그대로 무언가 첨가되고, 꾸며주는 구현을 말한다. 

![image](https://user-images.githubusercontent.com/62419307/90543381-9485f980-e1c0-11ea-8e83-764b25b4b59f.png)

보통 기능의 확장을 할 때 상속을 이용하지만 다양한 조합의 기능의 확장이 요구될 때는 클래스가 불필요하게 증가하는 문제가 발생한다. 이에 대한 예시로 커피를 주문할 때 휘핑크림이나, 우유를 첨가할 수도있고, 시럽도 추가가 가능하다. 그리고 포장여부까지 더해지면 점점 기능이 복잡해지고, 계층적 구조가 많아진다. 

이러한 경우에 해결할 수 있는 방법이 데코레이터 패턴이다. 상속이 아닌 위임을 하는 방식으로 기능을 확장시킬 수 있다. 

![image](https://user-images.githubusercontent.com/62419307/90543438-ac5d7d80-e1c0-11ea-8155-641995a5af3e.png)

위 이미지는 데코레이터 패턴을 적용해서 클래스 다이어그램이다. 인터페이스가 아닌 추상클래스를 통해서 구현을 했다. component는 Beverage 추상클래스가 되고, 기본 음료의 종류들이 concrete component가 된다. 그리고 커피에 첨가하고 싶은 것은 decorator 추상클래스에 위임한다.

<br>

### 퍼사드 패턴 (Facade Pattern) 🍋

퍼사드는 클래스 라이브러리 같은 **어떤 소프트웨어의 다른 커다란 코드 부분에 대한 간략화된 인터페이스를 제공하는 객체**이다. 몇 개의 복잡한 서브시스템들과 클라이언트 사이에 Facade라는 객체를 세워놓음으로써 복잡한 관계를 정리 혹은 구조화하는 패턴이라고 생각하면 된다. 즉, 사용자가 자판기를 이용할 때 음료수를 뽑아먹으면 되지 그 과정에 대해 알 필요가 없도록 전면에 Facade를 내세우는 것이다.

<br>

### 플라이웨이트 패턴 (Flyweight pattern) 🍇

객체의 내부에서 참조하는 **객체를 직접 만드는 것이 아니라, 없다면 만들고, 만들어져 있다면 객체를 공유하는 식으로 객체를 구성하는 방법**이다. 이렇게 하기 위해 대부분 팩토리 메소드 패턴을 사용해 객체를 생성한다. 팩토리 메소드 안에서는 객체(Flyweight 객체)를 새로 생성한다. 이때 생성하는 객체가 내부적으로 참조하는 객체에 대해, 기존에 있는 객체를 참조만 하는 식으로 객체를 구성한다. 이렇게 하면 객체의 할당에 사용되는 메모리를 줄일 수 있을 뿐 아니라, 객체를 생성하는 시간이 소요되지 않는다.

아래 중 해당하는 사항이 많은 상황일수록 플라이웨이트 패턴을 적용하기에 적합하다.

- 어플리케이션에 의해 생성되는 객체의 수가 많아야 한다.
- 생성된 객체가 오래도록 메모리에 상주하며, 사용되는 횟수가 많다.
- 객체의 특성을 내적 속성(Intrinsic Properties)과 외적 속성(Extrinsic Properties)으로 나눴을 때, 객체의 외적 특성이 클라이언트 프로그램으로부터 정의되어야 한다.

대표적인 예로, 자바의 **모든 래퍼 클래스의 valueOf() 메소드!** 래퍼 클래스를 생성해야 할 때 new 키워드를 통해 인스턴스를 매번 생성하기보다는 valueOf() 메소드를 통해 생성하는 것이 더 효율적이다.

**➕ 참고 자료가 정말 재밌다! 꼭 읽기!** 

<br>

### 프록시 패턴 (Proxy Pattern) 🍑

일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다. 이처럼 프록시의 의미는 "대리자"라는 의미다. 무언가를 대신해서 일을 해주는 사람을 말하는데 프록시패턴(Proxy Pattern)은 대리자로써 일을 맡기면 그 일을 처리하고 완료되면 결과를 알려주는 패턴이다. 

예를 들어, 우리가 시스템 명령어를 실행하는 객체를 갖고 있을 때 우리가 그 객체를 사용하는 것이라면 괜찮지만 만약 그 객체를 클라이언트에게 제공하려고 한다면 클라이언트 프로그램이 우리가 원치 않는 파일을 삭제하거나 설정을 변경하는 등의 명령을 내릴 수 있기 때문에 심각한 문제를 초래할 수 있다. 프록시 패턴은 클라이언트에게 접근에 대한 컨트롤을 제공하여 위와 같은 문제를 해결한다.

<br>

🌷 어댑터 패턴

[참고1](https://gyoogle.dev/blog/design-pattern/Adapter%20Pattern.html)

[참고2](https://meylady.tistory.com/56)

🌷 브리지 패턴

[참고1](https://simsimjae.tistory.com/226)

[참고2](https://lee1535.tistory.com/102)

🌷컴포지트 패턴

[참고1](https://ko.wikipedia.org/wiki/컴포지트_패턴)

[참고2](https://jusungpark.tistory.com/26?category=630296)

🌷 데코레이터 패턴

[참고1](https://meylady.tistory.com/57?category=795226)

🌷 퍼사드 패턴

[참고1](https://coding-start.tistory.com/197)

🌷 플라이웨이트 패턴

[참고1](https://m.blog.naver.com/2feelus/220669069127)

[참고2](https://readystory.tistory.com/137)

🌷 프록시 패턴

[참고1](https://readystory.tistory.com/132?category=822867)