# Memory Management 2

페이징 기법은 연속 할당 방식과 달리 동일한 크기의 페이지로 나눠서 어떤 위치든 사용할 수 있다는 특징이 있었다. 😊

그래서 주소 변환 절차도 연속 할당 방식에 비해 다소 복잡하다. 이제 주소 변환 절차에 대해서 살펴보자.

<br>

### 주소 변환 기법

페이징 기법은 특정 프로세스의 몇 번째 페이지가 물리적 메모리의 몇 번째 프레임에 들어가 있다는 페이지별 주소 변환 정보가 필요하다. 이를 위해 **페이지 테이블**(page table)을 가지며, 프로세스가 가질 수 있는 페이지 개수만큼 주소 변환 엔트리를 갖게 된다.

정리하자면, 페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 오프셋(d)으로 나누어 **주소 변환**(address translation)에 사용한다. 그리고 이 p는 페이지 테이블 접근 시 인덱스로 사용되고 d는 물리적 메모리상의 기준 주소로 사용된다.

![image](https://user-images.githubusercontent.com/62419307/115885642-1bdfe700-a48b-11eb-83e2-72a59957b98e.png)

[이미지 출처](https://blog.naver.com/PostView.nhn?blogId=bycho211&logNo=221028200599&proxyReferer=https:%2F%2Fwww.google.com%2F)

<br>

### 페이지 테이블의 구현

주소 바인딩에 대해서 배울 때 기준 레지스터와 한계 레지스터가 있다고 했다. 그러면 페이징 기법에서는 이를 어떻게 사용할까? 🙄

+ **페이지 테이블 기준 레지스터**(page-table base register)

  : 메모리 내에서의 페이지 테이블의 시작 위치를 나타냄

+ **페이지 테이블 길이 레지스터**(page-table length register)

  : 페이지 테이블 크기를 보관

<br>

예시에서는 페이지 테이블이 그냥 귀요미🐣로 보일지 몰라도 사실 크기가 엄청 커질 수 있다. 그래서 이 테이블을 레지스터에 저장하는 것이 불가능하고 주소 변환을 위한 테이블인데 하드디스크에 넣을 수도 없다... ☹

그래서! 메모리에 넣기로 했다. 하지만 이런 의문이 들 것이다. 음? 논리 주소를 가지고 물리적 메모리에 접근하기 위해서 페이지 테이블을 사용하는 건데 페이지 테이블을 메모리에 저장한다고? 😒

맞다! 그래서 매번 메모리에 접근하려면 메모리를 2번 접근해야 하는 오버헤드가 발생한다.

1. 물리적 메모리 주소를 알기 위해서 메모리에 위치한 페이지 테이블 접근
2. 페이지 테이블에 따른 프레임 접근

이 오버헤드를 줄일 수 없을까? 하는 생각에 등장한 것이 **TLB**(Translation Look-aside Buffer)라고 불리는 주소 변환용 하드웨어 캐시이다! 😲

<br>

캐시 메모리가 그렇듯 TLB로 사용되는 하드웨어는 비싸기 때문에 페이지 테이블의 모든 정보를 담을 수는 없다. 그래서 빈번히 참조되는 페이지에 대한 주소 변환 정보를 담게 된다.

+ 요청한 주소 변환 정보가 TLB에 있으면

  : 곧바로 대응하는 물리적 메모리의 프레임 정보를 얻을 수 있음.

+ 요청한 주소 변환 정보가 TLB에 없으면

  : 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 함. 즉, 두 번의 메모리 접근이 필요함

<br>

TLB는 페이지 테이블과 구성이 같을까? 그렇지는 않다. 아까 TLB는 가격이 바싸기 때문에 테이블의 모든 정보를 담을 수 없다고 했다. 즉, 일부만을 저장할 수 있기 때문에 페이지 번호가 있다고 해도 TLB에서 그 번호가 대응되지 않을 수 있다. 

다시 설명하자면, 페이지 테이블에서는 p에 해당하는 프레임 번호는 페이지 테이블에서 p번째를 보면 된다. 하지만 TLB는 모든 정보를 저장하는 건 아니기 때문에 **페이지 번호와 이에 대응되는 프레임 번호가 쌍으로 저장**되어야 한다.

![image](https://user-images.githubusercontent.com/62419307/115890822-51d39a00-a490-11eb-8c0f-c56ea5f89eaf.png)

[이미지 출처](https://goodmilktea.tistory.com/35)

그리고 TLB를 통해서 변환하려면 해당 페이지의 주소 변환 정보가 있는지 TLB의 모든 항목을 찾아 봐야 한다. 이 경우 오버헤드가 발생하므로 병렬 탐색이 가능한 연관 레지스터를 사용한다.

또한, 프로세스는 각자의 독립적인 주소 공간을 사용한다고 했다. 그러면 문맥 교환이 일어나면 어떻게 될까? 당연히 이전 프로세스의 주소 변환을 담고 있던 TLB 내용은 전부 지워야 한다.

<br>

### 계층적 페이지

우리가 사용하고 있는 현대의 컴퓨터는 주소 공간이 매우 큰 프로그램을 지원한다. 이 프로그램들을 메모리에 적재하고 사용한다면 페이지 테이블 역시 차지하는 크기가 클 것이다. 그렇게 되면 전체 메모리의 상당 부분이 주소 변환을 위한 페이지 테이블에 할애될 것이다.

따라서 페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 **2단계 페이징**(two-level paging) 기법을 사용한다.

<br>

#### 2단계 페이징

주소 변환을 위해 **외부 페이지 테이블**(outer page table)과 **내부 페이지 테이블**(inner page table)의 두 단계에 걸친 페이지 테이블을 사용한다.

이렇게 되면 사용하지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정하여 1단계 페이징 기법에 비해 메모리의 낭비를 줄일 수 있다! 하지만 주소 변환을 위해 접근해야 하는 페이지 테이블의 수가 증가하므로 시간적인 손해가 뒤따른다. 

![image](https://user-images.githubusercontent.com/62419307/115892160-db379c00-a491-11eb-9e8c-ccb80fd288d1.png)

2단계 페이징 기법에서는 프로세스의 논리적 주소를 두 종류의 페이지 번호(P1, P2)와 페이지 오프셋(d)으로 구분한다.

첫 번째 페이지 번호(P1)는 외부 페이지 테이블의 인덱스이고, 두 번째 페이지 번호(P2)는 내부 페이지 테이블의 인덱스이다. 이를 표현하면 <P1, P2, d>의 형태가 될 것이다.

먼저 외부 페이지 테이블로부터 P1만큼 떨어진 위치에서 내부 페이지 테이블의 주소를 얻게 되고 다음으로 내부 페이지 테이블로부터 P2만큼 떨어진 위치에서 요청된 페이지가 위치한 프레임 번호를 얻게 되어 마지막으로 해당 프레임으로부터 d만큼 떨어진 곳에서 원하는 정보를 얻을 수 있다.

프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 메모리 공간 낭비도 심해질 수 있다. 그래서 2단계를 넘어선 다단계 페이지 테이블이 필요하게 된다. 하지만 그만큼 메모리 접근 횟수가 많아서 비효율적이다.

그래서 이러한 시간적인 오버헤드를 줄이기 위해서는 TLB 사용이 효과적이다! 😏

다단계 페이지 테이블을 사용하면서 공간적인 효율과 TLB를 사용해서 시간적인 효율성 모두 얻을 수 있기 때문이다.