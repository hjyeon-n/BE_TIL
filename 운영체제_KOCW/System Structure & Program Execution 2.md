# System Structure & Program Execution 2

### 입출력 구조

입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것을 말한다.

+ **동기식 입출력**(synchronous I/O)

  어떤 프로그램이 입출력 요청을 했을 때, **입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식**

  이렇게 되면... 2가지 문제점이 발생한다. 😔

  1. 입출력이 완료될 때까지 CPU가 아무 일도 하지 못하기 때문에 자원의 낭비를 초래한다.
  2. 매 시점 시스템 내에서는 하나의 입출력 연산만이 수행될 수 있다.

  따라서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일을 할 수 있도록 관리한다. 예를 들어, B에게 CPU를 넘기고 A의 입출력이 완료될 때까지 A에게 CPU를 할당하지 않는다. 이는 입출력이 완료되지 않으면 CPU를 할당하더라도 명령을 수행하지 못하기 때문이다. 이를 관리하기 위해서 프로그램 상태를 **봉쇄 상태**(blocked state)로 전환한다.

+ **비동기식 입출력**(asynchronous I/O)

  입출력 연산을 요청한 후에 **연산이 끝나기를 기다리는 게 아니라 입출력 연산을 호출한 그 프로그램에게 CPU의 제어권을 곧바로 다시 부여하는 방식**

  동기식이 보통 read 연산일 때 사용하는 거에 비해 비동기식은 write 연산일 때 사용한다. 만약 프로그램 실행에 있어 현재 입출력 작업 중인 데이터가 필요하게 되면 결국 입출력 연산을 기다릴 수밖에 없는데, 비동기식인 경우에는 읽는 연산이 아니라 쓰는 연산이라면 입출력 작업이 완료되기 전에도 명령을 수행할 수 있다.



![image](https://user-images.githubusercontent.com/62419307/99179255-4355b980-275f-11eb-9044-02b7fad50b9d.png)

<br>

### 서로 다른 입출력 명령어

![image](https://user-images.githubusercontent.com/62419307/99179363-4d2bec80-2760-11eb-9291-660bace948ca.png)



+ 일반적인 메모리는 메인 메모리와 I/O 메모리 주소가 별도로 존재한다. 즉, I/O 디바이스에 접근하려면 메인 메모리 접근 instruction과 다른 instruction이 별개로 정의되어 있다. 

+ 오른쪽 그림은 **Memory Mapped I/O**라고 하며, I/O 디바이스에 메모리 주소를 매겨서 메모리 접근 instruction을 매개로 접근할 수 있다.

<br>

### 저장장치의 계층 구조

![image](https://user-images.githubusercontent.com/62419307/99179491-ab0d0400-2761-11eb-9886-ab0412c3eb30.png)

+ 상위 저장장치는 속도가 빠르며, 단위 공간당 가격이 높기 때문에 적은 용량을 사용한다. 또한 휘발성 저장장치이기 때문에 전원을 끄면 저장 내용이 사라진다.
+ 하위 저장장치는 속도가 느리지만, 단위 공간당 가격이 저렴하기 때문에 대용량을 사용할 수 있다. 또한 비휘발성 장치이기 때문에 전원을 끄더라도 내용이 지워지지 않는다.

하지만! 당장 필요한 정보만을 선별적으로 저장하면 하위에 있는 대용량의 저장장치를 갖고 있는 것과 같은 비슷한 성능 효과를 낼 수 있다. 이 기법이 바로 그 유명한 **캐싱 기법**이다. 😏

#### 🙋‍♀️ 캐싱 기법

캐싱 기법이란 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법이다. 즉, 재사용을 목적으로 한다. 

<br>

### 프로그램의 실행

"프로그램이 실행되고 있다"는 것은 두 가지 중요한 의미가 있다. 

1. 디스크에 존재하던 실행파일이 메모리에 적재된다.
2. 프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태이다.

그렇다면 프로그램이 물리적 메모리에 올라가는 모습은 어떨까? 🤔 

![image](https://user-images.githubusercontent.com/62419307/99179702-7d28bf00-2763-11eb-8526-11e5b457695b.png)

실행 파일 전체가 메모리에 올라갈 것이라는 예상과 달리, **필요한 부분만 메모리에 올라가고, 나머지는 디스크의 특정영역(스왑영역)에 내려가 있다.** 스왑영역에 대한 사진은 아래에서 확인할 수 있다! 😉

왜 이런 방식을 사용하지? 🤷‍♀️ 싶지만 여러 프로그램이 함께 사용하는 메모리 공간이니까 효율적으로 사용해야 하기 때문이다!

<br>

우선, 프로세스의 주소 공간에 대해 알아보자🔍

![image](https://user-images.githubusercontent.com/62419307/99179966-90d52500-2765-11eb-81f1-42380c14133e.png)

프로세스의 주소 공간은 **코드, 데이터, 스택** 등으로 구성된다. 각자의 프로그램마다 이러한 주소공간을 **별도로** 가지며, 이와 같은 주소 공간을 **가상메모리**(virtual memory) 또는 **논리적 메모리**(logical memory)라고 부른다. 

#### 메모리면 메모리지 왜 이렇게 부르는 거야? 😒

실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소공간을 가지기 때문!

<br>

#### 저 그림의 커널은 왜 있어? 👀

운영체제도 똑같이 코드, 데이터, 스택의 주소 공간 구성을 가지고 있다. 

![image](https://user-images.githubusercontent.com/62419307/99179987-ba8e4c00-2765-11eb-97d3-cfae7985d56a.png)

+ 코드

  운영체제는 그 목적에 맞게 CPU, 메모리 등의 자원 관리 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이루고 있다. 또한 시스템 콜과 인터럽트 처리 부분도 포함한다.

+ 데이터

  자원을 관리하기 위한 자료구조가 저장되어 있다. 또한 현재 수행 중인 프로그램을 관리하기 위한 자료구조도 커널의 데이터 영역에 유지된다. 이러한 자료구조를 PCB라고 한다.

+ 스택

  함수호출 시의 복귀 주소를 저장하기 위한 용도로 사용된다. 일반 사용자 프로그램의 스택과 달리 현재 수행 중인 프로세스마다 별도의 스택을 두어 따로 관리한다. 이는 시스템 콜이나 인터럽트 등으로 운영체제의 코드가 실행되기 때문이다. 

  다만, 여기서 유의해야 할 점은 프로그램 내의 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장하지만 시스템 콜이나 인터럽트가 발생했을 때는 OS가 CPU를 할당받게 되므로 직전 프로그램 복귀 정보를 PCB에 저장하게 된다.

<br>

### 사용자 프로그램이 사용하는 함수

+ 사용자 정의 함수

  프로그래머 본인이 직접 작성한 함수

+ 라이브러리 함수

  프로그래머 본인이 직접 작성하지는 않았지만 이미 누가 작성해놓은 함수를 호출해서 사용하는 경우

+ 커널 함수

  운영체제 커널의 코드에 정의된 함수

사용자 정의 함수와 라이브러리 함수는 프로그램이 실행될 때, 해당 프로세스의 주소 공간에 포함되고 함수 호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.

커널도 별도의 주소 공간이 있기 때문에 커널 함수는 커널의 주소 공간에 코드가 정의된다. 즉, 시스템 콜이나 인터럽트 발생 시 사용자 프로그램이 운영체제 내에 있는 함수를 호출해서 사용하는 것이다.