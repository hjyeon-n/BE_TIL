# Process 1

### 프로세스의 개념

**프로세스**(process)란 **실행 중인 프로그램**을 뜻한다. 디스크에 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 비로소 프로세스라고 말할 수 있다. 프로세스를 이해하기 위해서는 **프로세스의 문맥**(context)에 대해 알 필요가 있다.

<br>

#### 프로세스 문맥이 뭐야? 🙄

프로세스의 문맥이란 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다. 프로세스의 문맥은 주소공간을 비롯해 레지스터에서 어떤 값을 가지고 있었는지, 시스템 콜 등을 통해 커널에서 수행한 일의 상태 등 다양한 정보를 포함한다.

그러면 프로세스의 문맥은 왜 필요할까? 🤔 이전에 정리했던 것처럼 시분할 시스템 환경에서는 타이머 인터럽트 등에 의하여 CPU를 사용한 후 뺏기거나 다시 얻는 등의 CPU 관리가 존재한다. 이때, 프로세스 문맥은 마치 책갈피처럼 여기까지 읽었어! 라고 알려주는 역할을 한다. 그렇게 되면 다시 CPU를 할당 받았을 때 처음부터 읽을 필요 없이 **프로세스 문맥을 확인한 후, 그 이후부터 실행하면 된다!**

<br>

프로세스의 문맥에는 크게 세 가지 분류가 있다.

+ 하드웨어 문맥

  CPU의 수행 상태를 나타내는 것으로 프로그램 카운터(PC) 값과 각종 레지스터에 저장하고 있는 값들을 의미한다.

+ 프로세스의 주소 공간

  프로세스는 코드, 데이터, 스택으로 구성되는 독자적인 주소 공간을 가지고 있다.

+ 커널상의 문맥

  운영체제는 프로세스를 관리하기 위해서 자료구조를 유지하는데 PCB와 커널 스택이 이에 해당한다. 커널 스택의 경우 커널 코드를 수행하기 위해 존재하는 것으로 여러 사용자 프로그램들이 커널에 접근할 수 있으므로 호출하는 프로세스 별로 별도의 스택이 존재한다.

<br>

### 프로세스의 상태

프로세스의 상태는 **실행, 준비, 봉쇄**의 세 가지로 구분할 수 있다.

![image](https://user-images.githubusercontent.com/62419307/99404906-7cdd1f00-292f-11eb-9328-d731b1542a0c.png)

+ 실행 (running)

  프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태를 말한다. CPU가 하나만 있는 시스템만 고려하므로 실제로 실행 상태에 있는 프로세스는 매 시점 하나뿐이다.

+ 준비 (ready)

  프로세스가 CPU가 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태를 가리킨다.

+ 봉쇄 (blocked, wait, sleep)

  CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태를 말한다. 예로는 시간이 오래 걸리는 I/O 작업을 진행 중일 때가 있다.

➕ 다른 상태들도 있어! 🙋‍♀️ 

시작 (new) 상태: 프로세스가 생성 중인 상태. 아직 메모리 획득을 승인 받지 않은 상태이다.

완료 (terminated) 상태: 프로세스 실행은 끝났지만, 정리할 게 남아있는 상태

<br>

### 프로세스 제어블록

프로세스 제어블록이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 말한다.

+ 프로세스의 상태 (process state)

  : CPU를 할당해도 되는지 여부를 결정하기 위해 필요

+ 프로그램 카운터(program counter)의 값

  : 다음에 수행할 명령의 위치를 가리킴

+ CPU 레지스터(CPU register)의 값

  : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지 나타냄

+ CPU 스케줄링 정보(CPU scheduling information), 메모리 관리 정보 (memory management information)

  : 프로세스의 CPU 스케줄링과 메모리 할당을 위해 필요한 정보

+ 자원 사용 정보 (acccounting information)

+ 입출력 상태 정보 (I/O status information)

<br>

### 문맥 교환

문맥교환이란 **하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정**을 뜻한다. 

문맥 교환 중에 원래 CPU를 보유하고 있던 프로세스는 문맥을 자신의 PCB에 저장하고 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 복원시키는 과정을 거친다. 이뿐만 아니라 문맥교환은 타이머 인터럽트 발생 시와 입출력 요청 등 봉쇄 상태가 되는 경우에도 발생할 수 있다.

단, 시스템 콜이나 인터럽트가 발생해 CPU 제어권을 운영체제에게 넘겨줄 때는 **문맥교환이라고 하지 않는다.** 단순히 사용자 모드에서 커널 모드로 전환하는 과정이기 때문이다. 또한 이 경우보다 문맥교환의 경우, 오버헤드가 더 크다.

![image](https://user-images.githubusercontent.com/62419307/99672520-db80d500-2ab6-11eb-95b7-f7745270d798.png)

[이미지 출처](https://jhi93.github.io/category/os/2019-11-27-operatingsystem-03-1/)

<br>

### 프로세스를 스케줄링하기 위한 큐

![image](https://user-images.githubusercontent.com/62419307/99673721-7b8b2e00-2ab8-11eb-9d06-12a208ab986d.png)

CPU를 기다리는 프로세스를 줄 세우는 **준비 큐**뿐만 아니라, 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 **장치 큐**를 둔다. 예를 들어 입출력 요청이 들어오게 되면 그 프로세스는 디스크 입출력 큐에 줄을 서게 되는 방식이다.

공유 데이터에 대해 접근할 때도 큐가 필요하다. 만약 동일한 데이터에 접근하게 되면 데이터의 일관성이 깨질 수 있기 때문이다. 따라서 공유 데이터를 이미 사용하고 있는 프로세스가 다 사용하고 반납할 때까지 다른 프로세스가 대기해야 한다. 이때 큐를 사용한다. 

**작업 큐**도 추가적으로 유지하는데, 시스템 내의 모든 프로세스를 관리하기 위한 큐를 말한다. 따라서 프로세스의 상태와 상관없이 모든 프로세스가 작업 큐에 속하게 된다.

<br>

#### 잠깐만! ✋

그럼 여기까지 프로세스가 어떻게 실행되고, 문맥교환은 어떤 과정인지 다시 한 번 정리해보겠다! 😏

프로세스A가 있다고 하자. 이 프로세스가 CPU의 제어권을 가지고 프로세스가 실행되는 중에 타이머 인터럽트가 발생했다. 즉, 너 사용시간 다 끝났어! 하고 인터럽트가 발생한 것이다. 그러면 CPU의 제어권은 운영체제로 이양된다. 👻

운영체제는 타이머 인터럽트 처리루틴으로 가서 수행 중이던 프로세스A의 문맥을 저장하고, 준비 상태에 있는 프로세스 중에서 CPU의 제어권을 부여할 프로세스를 선택한다. 이렇게 프로세스를 선택하고, 실제 할당까지 넘어가는 과정을 CPU 디스패치라 한다! 😙

그러면 원래 수행 중이던 프로세스는 준비 상태로 변하고, 새롭게 CPU를 할당 받은 프로세스는 실행 상태가 된다. 엇⁉ 어디서 많이 봤는데? 😲 싶으면 정답! 이를 바로 **문맥교환**이라고 한다.

문맥교환은 타이머 인터럽트 발생 뿐만 아니라 입출력 요청 등으로 봉쇄상태로 바뀌는 경우에도 생길 수 있다.

<br>

이제부터는 입출력을 요청한 프로세스의 상태 변화가 어떻게 일어나는지 정리해 보겠다! 🧙‍♀️

CPU가 기계어 명령을 하나씩 수행해 나가다가 가끔은 디스크에서 파일의 내용을 읽어오라는 입출력 명령을 받을 수 있다. 하지만 디스크까지 다녀오려면 시간이 오래 걸린다! ⏱ 그러면 다녀올 때까지 CPU가 기다리게 되면 후속 명령을 처리하지 못하게 돼서 비효율적으로 낭비될 수 있다. 따라서 입출력이 완료될 때까지 CPU를 반환한 다음 봉쇄 상태로 바뀌게 된다.

그러면 다시! CPU가 적절한 프로세스를 선택해 할당해 주는 디스패치 과정을 거치게 된다. 그러면 입출력은 어떻게 이루어지고 있는 걸까? 입출력을 요청한 프로세스가 디스크 입출력 큐에서 대기하다가 드디어 디스크 컨트롤러로부터 서비스를 받고 나면 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완료됐음을 알린다.

CPU는 다른 프로세스를 실행하다가 인터럽트를 확인하고 사용자 모드에서 커널모드로 전환하고 봉쇄 상태였던 프로세스A를 준비 상태로 바꾼 후, 장치의 로컬 버퍼에 있는 내용은 메모리로 이동시킨다.

이렇게 인터럽트 처리까지 끝나면 인터럽트 처리루틴 이전에 수행디던 프로세스에게 CPU를 다시 할당해 하던 일을 마저한다! 하지만 가끔은 입출력이 완료된 프로세스로 문맥교환이 일어나는 경우가 있다.

<br>

### 스케줄러

스케줄러란 **어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드**를 말한다.

+ **장기 스케줄러** (long term scheduler)

  작업 스케줄러(job scheduler)라고도 부르며, **어떤 프로세스를 준비 큐에서 진입시킬지를 결정하는 역할을 한다.** 

  준비 큐는 CPU 할당만 받으면 바로 실행시킬 수 있는 프로세스의 집합이기 때문에 **프로세스에게 메모리를 할당하는 문제**에 관여한다. 따라서, 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할을 한다. 

  하지만 현대의 시분할 시스템에서는 이 스케줄러를 사용하지 않고 바로 메모리를 할당해 준비 큐에 넣어준다.

  <br>

+ **단기 스케줄러** (short term scheduler)

  CPU 스케줄러 (CPU scheduler)라고도 하며, **준비 상태의 프로세스 중에서 어떤 프로세스를 실행 상태로 만들 것인지를 결정**하는 역할을 한다.

  <br>

+ **중기 스케줄러** (medium term scheduling)

  과도하게 많은 프로세스에게 메모리를 할당해 시스템 성능이 떨어지는 경우 이를 해결하기 위해 **메모리에 적재된 프로세스의 수를 동적으로 조절**하는 역할을 한다. 메모리에 올라와 있는 프로세스(1순위는 봉쇄상태)를 선정해 메모리에서 빼낸 후, 디스크의 스왑 영역에 저장해 둔다. 이를 **스왑 아웃**이라 한다.

  중기 스케줄러로 인해서 프로세스 상태에 **중지 상태**(suspended, stopped)가 추가된다. 중지 상태에 있는 프로세스는 외부에서 resume 해줘야 활성화된다. 따라서, 이 프로세스는 스왑 아웃된다.

  ![image](https://user-images.githubusercontent.com/62419307/99681932-0c1a3c00-2ac2-11eb-8ca7-e41533468ea0.png)

blocked: 자신이 요청한 event가 만족되면 Ready

suspended: 외부에서 resume해 줘야 Active