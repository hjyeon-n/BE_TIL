# CPU Scheduling 2

### 1. 선입선출 스케줄링

선입선출 스케줄링(First Come First Served : FCFS)은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식이다.

즉, 선착순으로 오는 프로세스를 먼저 처리하고 해당 프로세스가 CPU를 반납할 때까지 뺏을 수 없는 **비선점형** 스케줄링이다.

은행이라고 생각해 보자. 나는 5분이면 일을 다 마칠 수 있는데 앞에 대기하는 사람이 30분동안 작업을 하게 되면 꼼짝없이 기다려야 한다. 😂 이런 형상을 콘보이 현상 (Convoy effect)라고 하며, FCFS 스케줄링의 대표적인 단점이다.

선입선출 스케줄링은 이처럼 앞에서 대기하는 프로세스의 작업 시간에 따라 평균 대기시간이 크게 달라질 수 있다.

+ CPU 버스트가 긴 프로세스 : 평균 대기 시간이 길어짐
+ CPU 버스트가 짧은 프로세스 : 평균 대기 시간이 짧아짐

<br>

| 프로세스 | CPU 버스트 시간 |
| -------- | --------------- |
| P1       | 12              |
| P2       | 3               |
| P3       | 3               |

<br>

프로세스가 P1, P2, P3 순으로 들어왔다고 가정하자.

![image](https://user-images.githubusercontent.com/62419307/114901296-a010e980-9e4f-11eb-8f1b-e4191254d31d.png)

- 대기 시간 : P1 = 0, P2 = 12, P3 = 15
- 평균 대기시간 : (0 + 12 + 15) / 3 = 9

<br>

이번에는 프로세스가 P2, P3, P1 순서로 들어왔다고 가정하자.

![image](https://user-images.githubusercontent.com/62419307/114901947-46f58580-9e50-11eb-8b41-fc94374bc7ec.png)

- 대기 시간 : P1 : 6, P2 : 0, P3 = 3
- 평균 대기시간 : (6 + 0 + 3) / 2 = 3 

<br>

앞서 얘기했던 것처럼 FCFS 스케줄링에서는 CPU 버스트 시간이 짧은 프로세스가 앞에 올수록 유리하다. 😏

<br>

### 2. 최단작업 우선 스케줄링

최단작업 우선 스케줄링 알고리즘(Shortest Job First : SJF)은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다.

이 스케줄링을 사용하면 CPU 버스트가 짧은 프로세스들이 먼저 CPU를 사용한 후 준비 큐에서 빠져나오기 때문에 준비 큐에서 기다리는 전체적인 시간이 줄어들게 된다.

SJF 알고리즘은 이와 같이 **평균 대기시간을 가장 짧게 하는 최적 알고리즘 (optimal algorithm)**으로 알려져있다.

+ 비선점형 방식 

  : CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지 CPU를 빼앗지 않는 방식

+ 선점형 방식 (Shortest Remaining Time First : SRTF)

  : 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했을지라도 CPU 버스트가 더 짧은 프로세스가 도착하면 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식

✔ 만약, 프로세스들이 준비 큐에 한꺼번에 도착하고 후에 들어올 프로세스들이 없다고 하면 비선점형 방식과 선점형 방식은 서로 같은 결과를 내기도 한다. 하지만 일반적으로는 선점형 방식이 평균 대기 시간을 가장 많이 줄일 수 있는 방식이 된다. 🤸‍♀️

<br>

| 프로세스 | 도착 시간 | CPU 버스트 시간 |
| -------- | --------- | --------------- |
| P1       | 0         | 14              |
| P2       | 4         | 8               |
| P3       | 8         | 2               |
| P4       | 10        | 8               |

<br>

+ SJF 비선점형 스케줄링

  ![image](https://user-images.githubusercontent.com/62419307/114987546-4270b180-9ed0-11eb-82e7-eb89f1bf58ef.png)

  + 평균 대기시간 : (0 + 12 + 6 + 14) / 4 = 8

<br>

+ SJF 선점형 스케줄링

  + 평균 대기시간 : (18 + 2 + 0 + 4) / 4 = 6

  ![image](https://user-images.githubusercontent.com/62419307/114989471-68975100-9ed2-11eb-89d6-6fcc6088d85c.png)

<br>

 SJF 스케줄링의 기법의 구현에서 프로세스의 CPU 버스트 기간을 미리 알 수 없다는 점이 현실적으로 어렵다. 따라서 시간의 에측은 과거의 CPU 버스트 시간을 통해 이루어진다.

여기서 질문! 시스템에서 평균을 줄이는 것이 항상 좋은 방식일까? 🙋‍♀️

정답은 '아니다'! CPU 버스트가 짧은 프로세스들에게만 CPU를 할당하게 되면 CPU 버스트가 긴 프로세스는 준비 큐에서 무한히 기다려야 할 수도 있다. 이를 기아 현상(starvation)이라 한다. 

<br>

### 3. 우선순위 스케줄링

우선순위 스케줄링(Priority Scheduling)은 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다.

이때, 우선순위는 숫자로 표시되며 값이 작을수록 높은 우선순위를 갖는다고 가정하자. 우선순위를 결정하는 방식은 여러가지가 있다. 만약 CPU 버스트가 짧을수록 우선순위가 높다면 SJF와 동일한 의미가 된다. 즉, SJF도 일종의 Priority Scheduling이 될 수 있다.

+ 비선점형 스케줄링

  : CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지 CPU를 빼앗지 않는 방식

+ 선점형 스케줄링

  : 현재 CPU에서 수행 중인 프로세스보다 우선순위가 높은 프로세스가 도착한다면 이 프로세스가 CPU를 선점한다.

<br>

#### 우선순위 스케줄링... 완벽해 보이는데? 🧐

아쉽게도 SJF 비선점형 방식처럼 **기아 현상**이 발생할 수 있다는 문제점이 있다! 

이러한 문제점을 해결하기 위햐서 **노화(aging) 기법**을 활용한다.

✅ 노화 기법 : 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당 받을 수 있게 함.

<br>

### 4. 라운드 로빈 스케줄링

라운드 로빈 스케줄링 (Round Robin Scheduling)은 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 특정 시간으로 제한(이 시간을 할당시간이라고 함)하여 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수하여 준비 큐에 있는 다른 프로세스에게 CPU를 할당하는 방식이다.

즉, 위의 다른 스케줄링 방식보다 **시분할 시스템의 성질을 가장 잘 활용**한 스케줄링 방식이다.

+ 할당시간이 길면 FCFS와 같은 결과를 나타낸다.
+ 할당시간이 너무 짧으면 CPU를 사용하는 프로세스들이 빈번하게 교체돼서 문맥교환의 오버헤드가 커진다.

<br>

| 프로세스 | CPU 버스트 시간 |
| -------- | --------------- |
| P1       | 24              |
| P2       | 17              |
| P3       | 3               |

<br>

이때 할당시간이 10인 라운드 로빈 스케줄링을 적용하면 이렇게 된다.

![image](https://user-images.githubusercontent.com/62419307/114995519-de062000-9ed8-11eb-91b5-801df9a2d60b.png)

라운드 로빈 스케줄링은 두 가지 기본적인 목적이 있다.

1. CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있게 한다. (효율성)
2. CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 한다. (형평성)

라운드 로빈 스케줄링은 공정한 스케줄링 방식이라고 할 수 있는데 CPU를 쓰고자 하는 양에 따라 비례적으로 소요시간이 증가하기 때문이다. 다만, 할당시간을 너무 짧게 하면 문맥교환의 오버헤드가 증가해 시스템의 성능을 저하시킬 수 있다. 

CPU 버스트 시간을 10이라고 가정해 보자.

+ 할당시간을 10으로 한 경우 : 문맥교환이 일어나지 않음
+ 할당시간을 5로 한 경우 : 문맥교환이 1회 발생
+ 할당시간을 1로 한 경우 : 문맥교환이 9회 발생

이 경우 1번의 경우에서 CPU 이용률이 가장 높다. 두 번째 경우와 세 번째 경우에는 오버헤드가 발생하기 때문이다.

<br>

#### FCFS와 비교

CPU 버스트 시간이 10인 프로세스 10개가 모두 시각 0에 도착했다고 가정하자.

1. FCFS
   + 평균 대기시간 : 45
   + 평균 응답시간 : 45
   + 대기시간 : 90

2. RR (할당시간을 매우 짧게 했을 경우)
   + 평균 대기시간 : 90
   + 평균 소요시간 : 100

<br>

동일한 CPU 버스트 시간을 가지는 프로세스들에 라운드 로빈 스케줄링을 적용할 경우 평균 대기시간 및 평균 소요시간이 더 길어진다. 하지만 이 경우에도 평균 응답시간은 더 짧아진다.

<br>

### 5. 멀티레벨 큐

멀티레벨 큐(Multi-Level Queue)란 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법이다. 즉, 프로세스들이 CPU를 기다리기 위해 한 줄이 아니라 여러 줄로 서는 것이다. 

<br>

멀티레벨 큐에서 신경 써야 할 점! 🔎

1. 어떤 줄에 서 있는 프로세스를 우선적으로 스케줄링할 것인가
2. 프로세스가 도착했을 때 어느 줄에 세워야 할 것인가

![image](https://user-images.githubusercontent.com/62419307/115001195-6e932f00-9ede-11eb-90ba-1269333cfbda.png)

일반적으로 멀티레벨 큐에서 준비 큐는 전위 큐와 후위 큐로 분할한다.

+ 전위 큐 (foreground queue)
  + 대화형 작업
  + 응답시간을 짧게 하기 위해 라운드 로빈 스케줄링 활용
+ 후위 큐 (background queue)
  + 계산 위주의 작업
  + 응답시간이 크게 중요하지 않기 때문에 FCFS 스케줄링을 활용해서 문맥교환 오버헤드를 줄임

<br>

이제 큐 자체에 대한 스케줄링에 대해서도 알아보자. 👀 이 스케줄링은 여러 개의 준비 큐에 대해서 어느 큐에 먼저 CPU를 할당할 것인지 결정하기 위해 사용된다.

+ 고정 우선순위 방식 (fixed priority scheduling)
  + 큐에 고정적인 우선순위를 부여해 우선순위가 높은 큐를 먼저 서비스함
  + 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어 있을 때만 서비스함 → starvation이 발생할 수 있음
  + 신분제라고 생각하면 이해하기 쉬움. 
+ 타임 슬라이스 방식 (time slice)
  + 기아 현상을 해소할 수 있음
  + 각 큐에 CPU 시간을 적절한 비율로 할당

<br>

### 6. 멀티레벨 피드백 큐

멀티레벨 피드백 큐(Muti-Level Feedback Queue)는 멀티레벨 큐처럼 CPU를 기다리는 프로세스를 여러 큐에 줄을 세운다는 점이 동일하지만, 프로세스가 다른 큐로 이동 가능하다는 점이 다르다.

우선순위 스케줄링 방식에서 봤던 **노화 기법**처럼 멀티레벨 피드백 큐에서는 오래 기다렸으면 우선순위가 높은 큐로 이동할 수 있다. 😲

![image](https://user-images.githubusercontent.com/62419307/115004120-71435380-9ee1-11eb-89c8-43121c61d51e.png)

상위에 있는 큐일수록 우선순위가 높다. 프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐에 줄을 선다.

그렇게 되면 CPU 버스트가 짧은 대화형 프로세스들은 빨리 서비스를 받고 작업을 완료할 수 있다. 

CPU 버스트가 길면 어떻게 될까? 🙄

1. 5만큼의 시간동안 CPU를 할당 받았지만 작업을 완료하지 못해 하위 큐로 내려간다.
2. 추가 시간인 10만큼의 시간 동안에도 완료하지 못했다면 최하위 큐로 이동한다.

<br>

큐 사이를 이동할 수 있다는 차이점은 있지만 큐에 대한 스케줄링 방식은 멀티레벨 큐와 같다. 최상위 큐가 우선적으로 CPU를 할당받고 상위 큐가 비었을 때 하위 큐에 있는 프로세스들이 CPU를 할당받을 수 있다.

<br>

### 7. 다중처리기 스케줄링

다중처리기 시스템(Mutil-Processor System)은 CPU가 여러 개인 시스템을 말한다. 이런 환경에서는 프로세스를 준비 큐에 한 줄로 세워서 각 CPU가 알아서 다음 프로세스를 꺼낼 수 있도록 할 수 있다.

#### 음... 어디서 많이 봤는데? 🤔

공항에서 체크인하기 위해서 한 줄로 서거나 은행에서 대기하는 방식이라고 생각하면 된다. 만약에 내가 은행에서 대기 중인데 특정 창구에서만 일을 처리할 수 있는 작업이라면 더욱 복잡해진다. 이럴 때는 한 줄이 아니라 창구 별로 줄 세우기를 할 수도 있다.

다중처리기 스케줄링에서도 이와 같이 CPU별로 줄을 설 수 있다. 이 경우 일부 CPU에 작업이 편중될 수 있는데 이 현상을 방지하기 위해서 부하균형 (load balancing) 매커니즘이 필요하다.

+ 대칭형 다중처리(symmentric multi-processing) : 각 CPU가 알아서 스케줄링을 결정
+ 비대칭형 다중처리(asymmentric multi-processing) : 하나의 CPU가 다른 CPU들의 스케줄링 및 데이터 접근을 책임짐 

<br>

### 8. 실시간 스케줄링

실시간 시스템(Real-Time System)은 각 작업마다 데드라인이 있어 반드시 그 데드라인 안에 작업을 처리해야 한다.

+ 경성 실시간 시스템 (hard real-time system) : 정해진 시간에 반드시 해결해야 함
+ 연성 실시간 시스템 (soft real-tiem system) : 꼭 지키지 않아도 큰 문제가 발생하지 않음

<br>

실시간 스케줄링(real-time scheduling)은 빠른 서비스도 중요하지만 데드라인을 지키는 서비스가 더욱 중요하다.

따라서, EDF(Earlist Deadline First) 스케줄링을 사용해 데드라인이 얼마 남지 않은 요청을 먼저 처리한다.

<br>

### 9. 스레드 스케줄링

+ Local Scheduling
  + User Level 스레드의 경우 사용자 수준의 thread library에 의해 어떤 스레드를 스케줄할지 결정
  + OS 입장에서는 그 스레드의 존재를 모름. 따라서 프로세스에게 CPU를 줄지 말지를 결정함
  + 어떤 스레드에게 CPU를 줄 지는 **프로세스**가 결정함
+ Global Scheduling
  + Kernel Level 스레드의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 스레드를 스케줄할지 결정
  + OS도 스레드의 존재를 알기 때문에 프로세스처럼 스케줄링함

<br>

### 스케줄링 알고리즘의 평가

+ 큐잉 모델
+ 시뮬레이션
+ 구현 및 실측