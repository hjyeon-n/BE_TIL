# Memory Management 1

## 주소 바인딩 📝

이전에 프로세스에 대해 배우면서 각 프로세스는 독립적인 주소 공간을 할당 받는다고 하였다. 이 주소를 **논리적 주소**(logical address) 혹은 **가상 주소**(virtual address)라고 한다. 논리적 주소는 프로세스마다 독립적으로 할당되며 0번지부터 시작한다.

**물리적 주소**(physical address)는 물리적 메모리에 실제로 올라가는 위치를 말한다. 보통 물리적 메모리의 낮은 주소에는 OS가, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

덧붙이자면, 주소 바인딩은 Symbolic Address → Logical Address → Physical Address 단계로 이루어진다. Symbolic Address는 변수 이름이나 함수를 호출하는 것을 말한다.

<br>

#### 이것들이 무슨 관련이 있지? 🤷‍♀️

프로세스에 대해 배우면서 프로그램이 메모리에 올라가야 실행이 되고 그 상태를 프로세스라고 하였다. 즉, 프로그램은 물리적 메모리에 올라가야 한다. CPU에서 논리적 주소에 있는 값을 참조하려고 하면 실제 값이 물리적 메모리의 어느 주소에 있는지 연결 시켜줘야 한다. 이 과정을 **주소 바인딩**이라고 한다. 이제 바인딩의 과정에 대해서 배워보자! ✍

✅ 이미 눈치챘겠지만 CPU와 사용자 프로세스는 논리적 주소에 접근하지 실제 물리적 메모리에 접근하는 건 MMU가 하게 된다!

<br>

### 주소 바인딩 방식

![image](https://user-images.githubusercontent.com/62419307/115734271-88dc7980-a3c4-11eb-9afd-6c0117a5d7f1.png)

+ 컴파일 타임 바인딩 (compile time binding)
  + 프로그램을 컴파일할 때 물리적 메모리 주소가 결정되는 방식
  + 물리적 메모리의 위치를 변경하고 싶다면 재컴파일 해야 한다.
+ 로드 타임 바인딩 (load time binding)
  + 프로그램의 실행이 시작될 때 물리적 메모리 주소가 결정되는 방식
  + 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다.
  + 재배치 가능 코드 (relocatable code)를 생성한 경우에 사용 가능
+ 실행 시간 바인딩 (execution time binding 또는 run time binding)
  + 프로그램 실행을 시작한 후에도 물리적 메모리 상의 주소가 변경될 수 있는 방식
  + 따라서, 주소 매핑 테이블 (address mapping table)을 이용해 바인딩을 점검해야 한다.
  + 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 **MMU**(Memory Management Unit)라는 하드웨어 지원 필요

<br>

#### MMU? 중요한 건 알겠는데... 🙄

![image](https://user-images.githubusercontent.com/62419307/115735154-36e82380-a3c5-11eb-8baa-88176567fa7b.png)

MMU는 CPU가 논리적 주소를 참조하려할 때 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다. 이때 기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 갖고 있다.

MMU scheme에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다. 

예를 들어 CPU가 논리적 주소 `346번지`에 있는 내용을 요청하면 재배치 레지스터에 있는 `14000`이라는 값을 더해  물리적 메모리 `14346` 번지에 있는 내용을 참조하게 된다.

<br>

#### 음... 프로세스는 독립적인 주소 공간을 가지고 있다며! 😫

맞다! 그래서 100번지가 가리키는 내용이 프로세스마다 다르게 나올 것이다. 따라서 재배치 레지스터는 그 프로세스에 맞는 값으로 설정하게 된다. 또한 같이 배웠던 한계 레지스터는 요청 주소값과 실제 프로세스 크기를 비교해 메모리 보안을 지켜준다.

<br>

## 메모리 관리와 관련된 용어

### 1. 동적 로딩

**동적로딩**(dynamic loading)은 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리의 효율성을 높이기 위해 사용하는 기법 중 하나이다.

우리는 아까 MMU scheme에 대해 배우면서 주소 공간 전체를 메모리에 적재한다고 하였다. 하지만 실제로도 그럴까? 🤨 당연히 아니다! 

실제 프로그램은 예외 처리를 하는 코드가 많고 이 코드는 실제 실행 코드보다 사용빈도가 떨어지면서 용량은 더 많이 차지한다. 그래서 동적로딩은 **프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 것**을 말한다.

운영체제의 지원 없이 프로그램 자체에서 구현이 가능하며 라이브러리를 통해 운영체제가 지원할 수도 있다.

<br>

### 2. 동적 연결

**동적 연결**(dynamic linking)은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 방식이다. 

음... 이해하기가 어렵다. 😂 상반된 예시로 이해해 보자!  

정적연결(static linking)은 우리가 작성한 코드와 라이브러리 코드가 합쳐져서 실행파일이 완성된다. 이게 무슨 의미냐면 실행 파일 하나에 printf 라는 라이브러리 함수를 호출하고 있다고 생각하자. 그런 실행 파일이 100개가 있으면 똑같은 printf 라이브러리 코드가 100개가 있는 것이다! 😯

이에 반해 동적 연결은 라이브러리가 실행 시점에 연결된다. 예를 들어 하나의 실행 파일이 printf 라이브러리 함수를 호출한다면 그 부분에서 해당 라이브러리가 이미 메모리에 존재하는지 살펴보고 만약 있다면, 그 메모리 위치에서 참조하고 그렇지 않다면 디스크에서 파일을 찾아 메모리에 적재한 후 수행한다.

따라서, 동적 연결 방식은 공통으로 사용하는 부분을 메모리에 한번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.

<br>

### 3.  중첩

**중첩**(overlays)이란 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다. 어디서 많이 봤는데? 싶으면 맞다. 동적 로딩과 비슷한 개념이다. 하지만 사용 이유에서 차이가 있다.

중첩은 초창기 때 메모리에 크기가 큰 프로세스를 올릴 수 없을 때 그 프로세스를 분할해서 올리는 방법이었다. 이렇듯 다중 프로그래밍 환경에서 필요한 부분만 메모리에 적재하는 동적 로딩과는 다른 용도이다.

<br>

### 4. 스와핑

**스와핑**(swapping)이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것을 말한다. 이때 스왑 영역은 백킹스토어(backing store)라고 부르며 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다.

스와핑은 프로세스가 종료돼서 그 주소공간을 디스크로 내쫓는 게 아니라 수행 중인 프로세스의 주소공간을 일시적으로 메모리에서 디스크로 내려놓는 과정을 의미한다.

+ 스왑 인 (swap in) : 디스크에서 메모리로 올리는 작업
+ 스왑 아웃 (swap out) : 메모리에서 디스크로 내리는 작업

<br>

#### 그러면 스와핑은 어떻게 이루어지는 걸까? 🤔

중기 스케줄러가 스왑 아웃시킬 프로세스를 선정한다. 그러면 현재 메모리에 올라가 있는 주소 공간의 내용을 전부 디스크 스왑 영역에 스왑 아웃시킨다. 이 과정을 통해 메모리에 남아있는 프로그램들에게 실행에 필요한 적절한 메모리 공간을 보장한다. 

메모리에 있는 프로그램들이 충분히 실행이 되면 다시 스왑 인을 한다. 이때, 원래 존재하던 메모리 위치로 올라가야 하기 때문에 실행시간 바인딩 기법을 사용해 추후 빈 메모리 영역 아무 곳에나 프로세스를 적재한다.

<br>

## 물리적 메모리의 할당 방식

사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 **연속할당**(contiguous allocation) 방식과 **불연속할당**(noncontiguous allocation) 방식으로 나눌 수 있다.

![image](https://user-images.githubusercontent.com/62419307/115743994-1f149d80-a3cd-11eb-9a02-f796bdaa0271.png)

+ 연속 할당 방식
  + 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
  + 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.
    + 고정분할(fixed partition allocation) 방식 
    + 가변분할(variable partition allocation) 방식
+ 불연속 할당 방식
  + 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
    + 페이징(paging) 기법
    + 세그먼테이션(segmentation) 기법
    + 페이지드 세그먼테이션(paged segmentation) 기법

이제 더 자세하게 살펴보자! 🔎

<br>

### 1. 연속할당 방식

연속 할당 방식은 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식이다. 이때 물리적 메모리를 고정된 크기의 분할로 미리 나누어 놓는지, 그렇지 않은지에 따라 고정 분할 방식과 가변 분할 방식으로 나뉜다.

<br>

#### 고정 분할 방식

고정분할 방식은 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다. 이때 분할 크기를 고정시켜서 고정 분할 방식인 것이 아니라 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정돼서 고정 분할 방식이다. 분할의 크기는 상관이 없다. 😜

이 방식은 **외부조각**(external fragmentation)과 **내부조각**(internal fragmentation)이 발생할 수 있다.

+ 외부조각

  프로그램의 크기보다 분할의 크기가 작아서 해당 분할이 비어 있지만 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간

+ 내부조각

  프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간

<br>

#### 가변 분할 방식

가변분할 방식은 고정분할 방식과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식을 말한다.

이 방식은 분할의 크기를 프로그램의 크기보다 일부러 크게 할당하지는 않기 때문에 내부조각이 발생하지 않는다. 하지만 이미 메모리에 존재하는 프로그램이 종료될 경우 빈 공간이 발생하고 그 공간에서 새롭게 시작되는 프로그램의 크기보다 작으면 외부조각이 발생할 수 있다.

메모리 내 가용 공간 중 어떤 위치에 올릴 지를 결정하는 문제를 동적 메모리 할당 문제(dynamic storage-allocation problem)라고 한다.

+ **최초적합**(first-fit)
  + 크기가 n 이상인 가용 공간 중 가장 먼저 찾게되는 곳에 프로세스를 할당
  + 시간 측면에서 효율적
+ **최적적합** (best-fit)
  + 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 프로세스 할당
  + 공간 측면에서 효율적
+ **최악적합** (worst-fit)
  + 가용 공간 중에서 가장 크기가 큰 곳에 프로세스 할당
  + 시간 측면과 공간 측면 모두에서 비효율적

<br>

#### 컴팩션

![image](https://user-images.githubusercontent.com/62419307/115747506-4de04300-a3d0-11eb-81a8-d6acff3b5351.png)

쉽게 말해 디스크 조각 모음처럼 가용한 공간들을 조각조각 모으는 작업을 말한다. 즉, 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아 큰 가용 공간을 만드는 것이다.

<br>

### 2. 불연속할당 기법

불연속 할당 기법은 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 말한다. 페이징 기법과 세그먼테이션 기법, 페이지드 세그먼테이션 기법이 있다. 이 개념들은 중요하기 때문에 더 자세하게 알아보자! 😉

<br>

#### 페이징 기법

페이징 기법이란 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식을 말한다.

불연속할당 기법이기 때문에 주소 공간 전체를 물리적 메모리에 올릴 필요는 없고 일부는 메모리에, 일부는 백킹스토어에 두고 있어도 된다. 페이징 기법은 동일한 크기의 **프레임**(frame)으로 나누기 때문에 연속할당에서 발생했던 동적 메모리 할당 문제가 발생하지 않는다. 어떤 위치이든 사용이 가능하기 때문이다! 😎

그렇지만, 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 마지막 페이지는 내부조각이 발생할 수 있다.

<br>

#### 세그먼테이션

주소 공간은 일반적으로 코드, 데이터, 스택 등의 의미 있는 단위들로 구성되는데 세그먼트는 이와 같이 주소 공간을 기능 단위 또는 의미 단위로 나눈 것을 말한다.

논리적인 단위로 나눈 것이기 때문에 페이징 기법과 달리 크기가 균일하지 않다. 또한 크기가 균일하지 않아 메모리에 적재하는 부가적인 관리 오버헤드가 발생할 수 있다.

