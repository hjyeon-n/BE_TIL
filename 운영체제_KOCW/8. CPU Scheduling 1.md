# CPU Scheduling

### CPU가 수행하는 명령

CPU가 수행하는 명령은 ADD, Load, Store처럼 CPU 내에서만 수행이 되거나 비교적 속도가 빠른 메모리 접근 명령어 처리부터 I/O를 요청했을 때 제어권을 커널로 넘겨줘야 하는 명령어 처리 등 다양한 명령어를 처리할 수 있다.

이때, 전자의 경우를 **CPU burst**라고 하고, 후자를 **I/O burst**라고 한다. 각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지 않다. 따라서 프로세스를 크게 **I/O 바운드 프로세스**(I/O bound process), **CPU 바운드 프로세스**(CPU bound process)로 나누어 볼 수 있다. 

+ I/O 바운드 프로세스 : I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스 ex) 대화형 프로그램
+ CPU 바운드 프로세스 : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스 ex) 계산 위주의 프로그램

<br>

#### 그래서 이런 게 왜 중요한데? 🥱

이와 같이 CPU 버스트가 각각 다르기 때문에 CPU의 효율성을 높이려면 **CPU 스케줄러**가 필요하다! 😏 

<br>

### CPU 스케줄러

**CPU 스케줄러**는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다. 스케줄러라고 하니 별도의 장치라고 생각할 수 있지만 사실 코드라는 점! 😜 그러면 어떤 상황에 쓰일까?

1. 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우
2. 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
3. I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 프로세스의 상태가 준비 상태로 바뀌는 경우
4. CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

<br>

CPU 스케줄러에는 **비선점형**(nonpreemptive) 방식과 **선점형**(preemptive)방식이 있다.

+ 비선점형 방식 : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법
+ 선점형 방식 : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법

<br>

### 디스패처

아까 정리했던 것처럼 CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고 나면 선택된 프로세스에게 실제로 CPU 제어권을 넘겨줘야 한다. 이처럼 CPU 제어권을 넘겨주고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 **디스패처**(dispatcher)라고 한다.

그러니까! 디스패처는 현재 수행 중이던 프로세스의 문맥을 PCB에 저장하고 새롭게 선택된 프로세스의 문맥을 PCB에서 복원한 후에 그 프로세스에게 CPU를 넘기는 과정을 수행한다. 이때 소요되는 시간을 디스패치 지연시간이라고 하며 문맥교환 오버헤드가 된다. 이 과정은 Process 파트에서 많이 다뤘으니 더 구체적인 설명은 생략! 

<br>

### 스케줄링의 성능 평가

성능 평가 지표는 크게 시스템 관점의 지표와 사용자 관점의 지표로 나눌 수 있다.

+ 시스템 관점의 지표 : CPU 이용률과 처리량
+ 사용자 관점의 지표 : 소요시간, 대기시간, 응답시간

<br>

#### CPU 이용률

CPU 이용률(CPU utilization)은 **전체 시간 중에서 CPU가 일을 한 시간의 비율**을 나타낸다. CPU는 알다시피 고비용의 자원이기 때문에 계속 이용해 먹어야 한다! 🤑 따라서, CPU가 일을 하지 않고 휴면 상태에 머무르는 시간을 최대한 줄이는 게 스케줄링의 중요한 목표!

<br>

#### 처리량

처리량(throughput)은 주어진 시간 동안 **준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지**(CPU 버스트를 완료한 프로세스의 개수)를 나타낸다. 이때 프로세스 관점이 아니라 CPU의 관점으로 보는 것이 중요하다. 즉, 처리량은 몇 개의 프로세스가 CPU를 사용했는지를 나타내는 값이고 더 많은 프로세스들이 작업하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 할당하는 것이 유리하다.

<br>

#### 소요시간

소요시간(turnaround time)은 프로세스가 **CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간** 즉, 준비 큐에서 기다린 시간 + 실제 CPU를 사용한 시간의 합! 아까도 말했지만 CPU 관점이기 때문에 프로그램이 시작해서 종료하는 데 걸리는 시간이 아니라는 점, 알아두자! 😉

<br>

#### 대기시간

대기시간(wating time)은 CPU 버스트 기간 중 **프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합**을 뜻한다. 시분할 시스템에서는 CPU를 번갈아서 사용해야 하기 때문에 한 번의 CPU 버스트 중에도 준비 큐에서 대기하는 시간이 여러 번 발생할 수 있다.

<br>

#### 응답시간

응답시간(response time)은 **프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간**을 말한다. 응답시간은 대화형 시스템에 적합한 성능척도로, 사용자 입장에서 가장 중요한 성능척도라고 할 수 있다.

<br>

#### 다 거기서 거기 아냐...? 비슷해서 헷갈려! 😫

그래서 식당을 예로 들어서 정리해 보자! 👩‍🍳

식당에 주방장, 손님이 있다고 하면 이용률과 처리량이 식당 입장에서의 척도, 소요시간, 대기시간, 응답시간은 손님 입장에서의 척도이다.

+ 이용률 : 전체 시간 중 주방장이 일한 시간
+ 처리량 : 주방장이 주어진 시간 동안 몇 명의 손님에게 음식을 줬는지

사장 입장에서는 주방장이 최대한 일을 많이 하고, 한정된 시간동안 많은 손님들에게 요리를 대접할 수 있어야 좋다! 🤹‍♀️

<br>

+ 소요시간 : 손님이 식당에 들어와서 주문한 음식을 다 먹고 나가기까지 소요되는 시간
+ 대기시간 : 음식을 먹은 시간을 제외해서 순수하게 음식을 기다린 시간
+ 응답시간 : 최초의 음식이 나오기까지 기다린 시간

이때, 음식이 조금씩 여러 번에 걸쳐서 나오게 된다면 음식을 먹은 시간을 제외해서 음식들이 나오기까지 기다린 시간을 합한 것이 대기시간이 된다.