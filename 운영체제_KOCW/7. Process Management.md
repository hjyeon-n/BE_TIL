# Process Management

### 프로세스의 생성

운영체제는 프로세스를 어떻게 생성할까? 🙄

우리가 보고서 표지를 한 번 만들고 다른 보고서에도 재탕하듯이 프로세스도 한 번 만들고 나서 이를 **복제하는 방식으로 프로세스를 생성한다.** 이때 프로세스를 생성한 프로세스를 **부모 프로세스**, 새롭게 생성된 프로세스를 **자식 프로세스**라고 한다.

하지만 실제 세계와 차이점은 있다! 자식 프로세스가 먼저 종료돼야 부모 프로세스가 종료될 수 있는 규칙이 존재한다. 

만약, 부모 프로세스는 종료하고 싶은데 자식 프로세스는 계속 수행되어야 한다 양자로 이전하는 방식을 사용해 규칙을 지켜나간다!

<br>

#### 자원은 어떻게 얻을 수 있을까? 🌽

+ 운영체제로부터 직접 자원을 할당받는 경우

+ 부모 프로세스와 자원을 공유해서 사용하는 경우

  ➕ 모든 걸 copy하지 않고 공유할 수 있는 건 공유하는 모델도 있다! COW(Copy-On-Write) 🐄

  <br>

프로세스가 수행되는 모델도 다를 수 있다.

+ 부모와 자식이 공존하며 수행되는 모델

  : CPU를 획득하기 위해서 경쟁하는 관계가 됨

+ 자식이 종료될 때까지 부모가 기다리는 모델 ex) 유닉스 커맨드 창

<br>

#### 복사를 하면 결국 똑같은 건데 어떻게 새로운 프로세스라는 거지? 😯

물론, 복제를 했기 때문에 **독자적인 주소 공간**을 확보할 수 있지만 생각한대로 내용도 똑같다!

그래서 다른 프로그램을 수행하기 위해서는 새로운 프로그램의 주소 공간을 **덮어씌어 실행**해야 한다.

이를 유닉스 명령어를 통해서 살펴보자. ☺

+ fork() : 자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성
+ exec() : fork()를 통해 생성된 자식 프로세스에서 이 시스템 콜을 통해 새로운 프로그램으로 주소공간을 덮어씌움

<br>

코드를 통해서 더 구체적으로 알아보자! 🔎

```c
main() {
	if (fork() == 0) 
		printf("\n Hello, I am child!\n");
		
	else 
		printf("\n Hello, I am parent!\n");
}
```

#### fork()를 하면 자식 프로세스에서 또 fork()를 실행하니 무한으로 생성하는 거 아냐? 😖

사실 부모 프로세스와 자식 프로세스라고 표현하긴 하지만 실제로는 **복제인간**의 개념에 더 가깝다‼

즉, 나와 똑같은 프로세스를 생성한다는 것은 **나와 똑같은 기억을 가진 프로세스를 만드는 것이다.** 따라서 복제본도 나는 복제했다는 기억을 가진다. 그러니까 원본이랑 똑같은 생각을 하게 되기 때문에 **코드의 첫 부분부터 다시 실행하는 게 아니라 fork() 이후부터 수행한다.** 또한 자기가 원본인 줄 알기 때문에 사용자가 원본과 복제본을 비교하기 위해서는 fork의 반환값으로 구분을 해야 한다.

부모 프로세스는 자식 프로세스의 PID 값을 반환 받고, 자식 프로세스는 0을 반환 받는 것을 고려해서 각각 다른 일을 시킬 수 있다! 😎 

그러면 exec()도 쉽게 이해가 갈 것이다. exec()는 맨인블랙의 뉴럴라이저와 같다! 이전의 기억을 모두 잃게 하고 새로운 일을 시키는 것이다.

➕ wait() : 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용하는 시스템 콜 → 동기화 가능

<br>

### 프로세스의 종료 👻

+ 자발적 종료

  exit() : 시스템 콜을 통해 운영체제에게 자신이 종료됨을 알림 → 명시적으로 호출하지 않아도 됨

+ 비자발적 종료

  abort() 함수를 통해 부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킴

  1. 자식 프로세스가 할당 자원의 한계치를 넘는 자원을 요구할 때
  2. 자식 프로세스에게 할당한 작업이 필요하지 않을 때
  3. 부모 프로세스가 종료될 때

<br>

### 프로세스 간의 협력 🤝

아까 말했듯이 프로세스는 각자 **독립적인 주소 공간**을 할당 받는다. 또한, **한 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.** 즉, 완전히 독립적인 관계가 된다. 그러면 프로세스들끼리 통신하는 방법은 전혀 없을까? 🤷‍♀️

그래서 나온 게 바로 **IPC!**(Inter-Process Communication)

<br>

#### IPC에 대해서 더 알려줘! 🙋‍♀️

IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신을 말한다. 두 가지 대표 방식이 있다.

+ `메시지 전달 (message passing)`

  : 공유 데이터를 전혀 사용하지 않고 메시지를 주고받으면서 통신하는 방식

  하지만 두 프로세스는 주소 공간이 다르기 때문에 커널한테 메시지 전달을 부탁하게 된다. 즉, 시스템 콜 방식을 사용한다.

  + **직접 통신** (direct communication)

    : 통신하려는 프로세스의 이름을 **명시적으로 표시**한다. 즉, 메시지를 보낼 때 수신할 프로세스의 이름을 표시하는 것으로, 자동으로 링크가 생성된다.

  + **간접 통신** (indirect communication)

    : 메시지를 메일박스 또는 포트로부터 전달 받음. 즉, 메일박스를 공유하는 프로세스들만 서로 통신을 할 수 있다.

+ `공유메모리 (shared memory)`

  : 시스템 콜을 통해 서로 다른 프로세스들이 주소 공간 중 일부를 공유할 수 있도록 한다. 다만 서로의 데이터에 일관성 문제가 발생할 수 있으나, 커널이 책임지지 않기 때문에 프로세스가 직접 동기화 문제를 책임져야 한다.

