# Memory Management 3, 4

### 메모리 보호

우리는 지난 시간에 페이지 테이블을 배우면서 페이지 테이블은 p만큼 떨어져 있는 곳에 해당하는 프레임 번호가 있다고 배웠다. 😎

그래서 페이지 테이블엔 프레임 번호밖에 없을 거라고 생각했는데 사실 아니다! 

페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 **보호비트**(protection)와 **유효-무효 비트**(valid-invalid bit)를 두고 있다.

![image](https://user-images.githubusercontent.com/62419307/115959973-ea7a2080-a549-11eb-90d7-daac3075f031.png)

#### 보호비트

보호비트는 각 페이지에 대한 접근 권한의 내용을 담고 있다. 여기서 주의할 점은 프로세스의 주소공간은 그 프로세스 자신만 접근할 수 있기 때문에 어떤 프로세스마다의 접근 권한을 의미하는 것이 아니다. 대신, 각 페이지에 대해 어떤 접근을 허용하는지의 정보가 저장된다. (읽기-쓰기, 읽기 전용)

<br>

#### 유효-무효 비트

우선, 페이지 테이블을 보자. 페이지는 5번까지 있는데 페이지 테이블의 엔트리는 7번까지 있다. 이유가 뭘까? 🙄

페이지 테이블은프로그램의 주소 공간이 가질 수 있는 최대 크기만큼 엔트리를 가지고 있어야 한다.

테이블이라는 자료구조 특성상 위에서부터 인덱스로 접근이 돼야 하기 때문이다. 대신 사용이 되지 않기 때문에 Invalid로 표시하고 있다.

Valid는 0번 페이지가 2번 프레임에 실제로 올라왔다는 이야기이다. 반면에 Invalid는 아예 사용하지 않거나 당장 필요한 것은 물리적 메모리에 올려져 있지만 그렇지 않은 부분은 백킹스토어에 있을 것이다. 이 부분을 표시한 게 바로 Invalid라고 이해하면 된다!

<br>

### 역페이지 테이블

우리는 지난 시간에 페이지 테이블을 공간 효율적으로 관리하는 계층적 페이징 기법에 대해 살펴보았다. ☺

페이지 테이블로 인한 메모리 공간의 낭비가 심한 이유는 모든 프로세스의 모든 페이지에 대해 페이지 테이블 항목을 다 구성해야 했기 때문이다. 이 문제를 해결하기 위해서 나온 방법이 **역페이지 테이블 기법**(inverted page table)이다.

![image](https://user-images.githubusercontent.com/62419307/115960396-20b89f80-a54c-11eb-838a-c6ad214f6098.png)

[이미지 출처](https://devowen.com/258)

역페이지 테이블 기법은 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식이다.

즉, 논리적 주소에 대해서 페이지 테이블을 만드는 것이 아니라 **물리적 주소에 대해 페이지 테이블을 만드는 것**이다. 그렇게 되면 시스템 전체에 대해 페이지 테이블을 하나만 둘 수 있다. 쉽게 말하면 물리적 메모리의 프레임 개수만큼 페이지 테이블의 엔트리 개수가 존재한다.

이전까지는 페이지 테이블에 프레임 번호를 저장했더라면 역페이지 기법에서 페이지 테이블의 각 항목은 어느 프로세스(pid)의 어느 페이지(p)가 이 프레임에 저장되었는지를 저장한다.

<br>

#### 음, 그럼 효율적인 방법이야? 😒

사실은 그렇지 않대! 역페이지 테이블 기법은 pid, p를 가지고 페이지 테이블을 전체 탐색해야 하고 그때의 위치 i가 바로 물리적 메모리에서 i번째 해당한다~ 라는 방법인데 이 방법은 결국 거꾸로 물리적 주소로부터 논리적 주소를 얻는 방법이다.

그래서 TLB에서 그랬던 것처럼 역페이지 테이블에서도 연관 레지스터를 이용해 병렬탐색을 가능하게 해서 시간적 효율성을 꾀한다.

<br>

### 공유 페이지

공유 페이지에 대해 알아보기 전에 먼저 공유 코드에 대해 알아보자.

**공유 코드**(shared code)는 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드이다. 공유하고 있기 때문에 읽기전용(read-only) 특성을 가지고 있다.

**공유 페이지**(shared page)는 이러한 공유 코드를 담는 페이지다. 여러 프로세스에서 공유되기 때문에 물리적 메모리에 하나만 적재하여 메모리를 효율적으로 사용한다.

![image](https://user-images.githubusercontent.com/62419307/115960946-26fc4b00-a54f-11eb-8aeb-046cc6a512b1.png)

[이미지 출처](https://yangjaeleeblog.wordpress.com/2017/05/24/%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B5%AC%EC%A1%B0/)

공유 페이지는 공유코드처럼 읽기 전용의 성질을 가져야 하고, 동일한 물리적 주소 뿐만 아니라 모든 프로세스의 논리적 주소 공간에서 동일한 위치에서 존재해야 한다.

<br>

#### 물리적 주소는 알겠는데 논리적 주소는 왜...? 🤔

[주소 바인딩](https://github.com/hjyeon-n/BE_TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_KOCW/14.%20Memory%20Management%201.md)에 대해 배웠을 때를 생각해 보자!

어떤 바인딩 방식이더라도 code 안에 논리적 주소가 그대로 저장된다. 따라서 그 주소에 해당하는 값을 이용하기 때문에 논리적 주소 또한 같아야 한다.

<br>

## 세그먼테이션

이전에 [세그먼테이션 기법](https://github.com/hjyeon-n/BE_TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_KOCW/14.%20Memory%20Management%201.md)에 대해서 배운 적이 있다. 이번에는 좀 더 자세하게 알아보자! 🔎

세그먼트는 **주소 공간을 기능 단위 또는 의미 단위로 나눈 것**을 말하며 세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용된다.

세그먼테이션 기법 또한 주소 변환을 위해 세그먼트 테이블을 사용한다. 이때, 세그먼트 테이블의 각 항목은 기준점(base)와 한계점(limit)을 가진다. 페이징 기법에서는 모두 동일한 크기의 페이지로 나뉘기 때문에 이런 것들이 필요하지 않았지만 세그먼테이션 기법에서는 크기가 균일하지 않기 때문에 이러한 정보가 필요하다. 대신, 세그먼트 테이블의 크기가 페이지 테이블의 크기보다 작다.

페이징 기법에서 PTBR, PRLR의 도움을 받았던 것처럼 세그먼테이션 기법도 **세그먼트 테이블 기준 레지스터**(Segment-Table Base Register: STBR)와 **세그먼트 테이블 길이 레지스터**(Segment-Table Length Register : STLR)을 사용한다. STBR은 메모리의 시작 주소를 담고 있고 STBR은 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되었는지 알려준다.

<br>

이제 가장 중요한 논리적 주소를 물리적 주소로 변환시켜 보자! 그전에 알아야 할 것이 있다. 🤓

+ 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가
+ 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은 값인가

![image](https://user-images.githubusercontent.com/62419307/115962176-164ed380-a555-11eb-9521-7d3e2c0bf861.png)

[이미지 출처](https://wansook0316.github.io/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-15-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98.html)

<br>

페이징 기법과 마찬가지로 세그먼테이션 기법에서도 세그먼트 테이블의 각 항목에 보호비트와 유효비트를 둔다.

세그먼트는 의미 단위로 나누어져 있기 때문에 **공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적이다.** 주소 공간의 일부를 공유하거나 특정 주소 공간에 접근 권한 제어를 할 경우, 페이징처럼 크기 단위보다 세그먼트의 의미 단위로 이루어지기 때문이다.

하지만 의미 단위로 나누기 때문에 물리적 메모리 관리에서 외부 조각이 발생하게 되며, 세그먼트를 어느 가용 공간에 할당할 것인가 결정하는 문제가 발생한다. 즉, 연속할당 메모리 관리의 가변분할 방식에서의 문제와 동일한 범주의 문제가 발생한다.

따라서 세그먼테이션 기법에서도 마찬가지로 최초적합, 최적적합 방식이 있다.

<br>

### 페이지드 세그먼테이션

페이징 기법과 세그먼테이션 기법에 대해 배우면서 장단점을 알 수 있었다! 그러면 두 기법을 섞어서 사용하면 어떨까? 그렇게 등장한 것이 **페이지드 세그먼테이션**(paged segmentation) 기법이다. 🤗

이 기법은 세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나눈다. 하지만 이 세그먼트가 동일한 크기 페이지들의 집합으로 구성돼야 한다. 그리고 물리적 메모리에 적재하는 단위는 페이지 단위로 한다.

이렇게 구성하면 어떤 장점이 있을까? 세그먼테이션 기법은 일정한 크기가 아니기 때문에 외부 조각이 발생한다고 했다. 하지만 동일한 크기로 나눔으로써 외부 조각 문제가 사라지고, 세그먼테이션 기법의 장점이던 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 하여 페이징 기법의 단점도 보완할 수 있다.

![image](https://user-images.githubusercontent.com/62419307/115985954-1d272600-a5e9-11eb-8ee4-4fb90914260c.png)

페이지드 세그먼테이션 기법에서는 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블을 사용한다.

하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지 테이블을 가지게 되면서 2단계 페이지 테이블과 유사한 구조라고 할 수 있다.

이제 페이지드 세그먼테이션 기법에서 주소 변환은 어떻게 이루어지는지 알아보자! 🔎

1. 논리적 주소에서 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근한다.
2. 이 항목에는 세그먼트 길이와 세그먼트 테이블의 시작 주소가 들어있다. 세그먼트 길이를 오프셋 값과 비교하여 유효한 위치인지 확인한다.
3. 오프셋 값은 상위 비트와 하위 비트로 나눠서 상위 비트는 세그먼트 내에서의 페이지 번호로 쓰고 하위 비트는 페이지 내에서의 범위로 사용한다.
4. 2번에서 세그먼트 테이블의 시작 위치를 얻었으므로 그 위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 프레임 번호를 알게 된다.
5. 4번의 프레임 번호와 3번에서 구한 하위 비트를 오프셋으로 사용하여 물리적 메모리 주소를 알아낸다.

<br>

#### 여기서 잠깐! 🙋‍♀️

우리는 지금 운영체제에 대해서 배우고 있는데 주소 변환에서 운영체제가 하는 일은 뭘까? 👩‍💻

정답은 "없다" 이다! 주소 변환은 하드웨어가 담당하고 있다. I/O 작업의 경우엔 CPU가 I/O 장치에 접근할 수 없기 때문에 운영체제 커널이 이를 맡는다고 하였다. 하지만 운영체제도 하나의 프로그램이기 때문에 CPU가 수행 중인 작업을 제어권을 넘겨받지 않은 채 사용할 수는 없다! 다음에 배울 '가상 메모리'에서는 운영체제의 역할이 필요하다는 것을 미리 알아두자!