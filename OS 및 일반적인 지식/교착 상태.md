# 교착 상태 (Deadlock) 🚗🚙🚚

### 시스템 모델 (System Model) 💻

- 자원들의 유형

  : CPU 주기, 메모리 공간, 파일, 입출력 장치 등

- 프로세스는 다음 순서로 자원을 이용

  1. 요청: 요청은 즉시 허용되지 않으면, 프로세스는 그 자원을 할당받을 때까지 대기
  2. 사용: 프로세스는 자원을 이용
  3. 해제: 프로세스는 요청에 의해 할당된 자원을 사용 후 해제

  <br>

### 교착 상태란? 🙋‍♀️

- 프로세스들에 의해 발생할 사건을 프로세스들이 서로 기다리고 있는 상태
- 둘 이상의 작업이 보류 상태에 놓여 자원을 이용하기 위해 서로 기다릴 때 발생

![](https://user-images.githubusercontent.com/62419307/89416229-e3b33f80-d767-11ea-94d9-05b4c82f1bf3.png)

<br>

### 교착 상태의 특징 ✅

- #### 교착 상태 발생의 필요 조건 

  1. **상호배제**: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 한다.
  2. **점유와 대기**: 최소한 자원 하나를 보유하고, 다른 프로세스에 할당된 자원을 얻기 위해 기다리는 프로세스가 있어야 한다.
  3. **비선점**: 자원을 강제로 뺏을 수 없다. 자원 점유 프로세스가 끝나야 해제
  4. **순환대기 (환형대기)**: 프로세스의 집합에서 순환 형태로 자원을 대기

  ✔ 네 가지 모두 충족해야 교착 상태 발생

  <br>

- #### 자원 할당 그래프 

  ![image-20200805221638950](C:\Users\jiyeon Hyun\AppData\Roaming\Typora\typora-user-images\image-20200805221638950.png)

  

  [참고](https://developerhenrycho.tistory.com/20)

  1. 첫 번째 그림의 경우 사이클 내의 공유 자원들이 모두 싸이클을 형성하고 있는 프로세스들에 의해 점유되고 있다. 

     → 교착상태 ⭕

  2. 두 번째 그림과 같이 사이클을 형성하고 있지만 공유 자원의 인스턴스들을 사이클을 형성하는 프로세스 이외의 다른 프로세스들도 점유 하고 있는 경우, 그 프로세스들이 lock을 풀면 다른 프로세스가 자원을 사용할 수 있다.

     → 교착상태 ❌

  

  그래프에서 사이클의 존재는 **교착의 필요 조건**

  ✔ 사이클이 존재하면 교착 상태일 수는 있으나, 사이클이 없으면 교착 상태는 아님

  <br>

### 교착 상태 처리 방법 🚗💨

- 교착 상태가 되지 않도록 하는 프로토콜을 사용
  - 교착 상태 예방 (Deadlock Prevention)
  - 교착 상태 회피 (Deadlock Avoidance)
- 시스템이 교착 상태에 들어가도록 허용한 다음에 회복
  - 교착 상태 탐지 및 회복
- 교착 상태가 시스템에서 발생하지 않은 것처럼 무시
  - 대부분의 운영체제에서 사용

<br>

### 교착 상태 예방 (Deadlock Prevention) 🙅‍♀️

**✔ 교착 상태 발생 조건 중 하나만 성립하지 않도록 함**

1. 상호 배제 (Mutual Exclusion)

   - **여러 프로세스가 공유 자원을 사용**

2. 점유와 대기 (Hold and Wait)

   - 프로세스는 **수행 전에 필요한 모든 자원을 요청하여 할당**: 자원 활용의 효율성 감소
   - 프로세스가 자원을 가지고 있지 않은 상태에서만 자원 요청을 할 수 있도록 허용: 기아 상태 유발

3. 비선점 (No Preemtion)

   - **자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납**

4. 순환 대기 (Circular Wait)

   - **모든 자원들에 번호를 부여해 전체 순서를 결정**

   - 한 프로세스는 자신이 가진 자원보다 번호가 큰 것만 요청

     → 내려갈 일이 없어 순환대기가 발생하지 않을 것이다.

<br>

### 교착 상태 회피 (Deadlock Avoidance) 🤷‍♀️

1. 교착 상태 예방보다 덜 엄격한 조건을 요구하기 때문에 자원의 효율성이 향상
   - 예방: 자원 사용 제약 조건을 정적으로 사전에 설정
   - 회피: 자원 사용 제약 조건을 동적으로 실행 중에 설정
2. 자원 요청 시, 자원할당으로 인해서 교착상태 유발 가능성 여부 검사
   - 교착 상태 유발 가능성이 전혀 없으면 (**안정 상태**), 자원 할당
   - 교착 상태 유발 가능성이 존재하면(**불안정 상태**), 자원 할당 연기
3. 어느 상태에서 자원 할당을 한 결과가 교착을 유발할 수 있는가에 대한 추가 정보 필요

<br>

#### ➕ 은행원 알고리즘

: 교착 상태 회피 알고리즘의 대표적인 예

- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기
- Available, Max, Allocation, Need 자료구조 사용

단점 😥

- 할당할 수 있는 자원의 일정량을 요구함
- 사용자 프로세스 수가 일정해야 함
- 사용자가 최대 필요량을 미리 알려주도록 요구
- 교착상태 회피 알고리즘을 실행하면 시스템 과부하가 증가함
- 항상 불안정상태를 방지해야 하므로 자원 이용도가 낮음

[참고1](https://gyoogle.dev/blog/computer-science/operation-system/DeadLock.html), [참고2](https://jhnyang.tistory.com/102)

<br>

### 교착 상태 탐지 (Deadlock Detection) 🔍

- 교착 상태가 발생하도록 허용
- 교착 상태가 발생했는지 탐지 알고리즘
- 교착 상태로부터 회복하는 알고리즘 제공
- 탐지 알고리즘 호출 문제는 교착상태 발생 빈도수와 교착상태 발생 시 영향을 받는 프로세스의 수에 따라 결정

<br>

### 교착 상태 회복 (Deadlock Recovery) 🛠

교착 상태가 소멸될 때까지 프로세스 종료 또는 자원 선점

- 프로세스 종료
  - 모든 교착 상태 프로세스들을 중지
  - 교착 상태 사이클이 제거될 때까지 하나씩 프로세스를 중지
- 자원 선점
  - 선점한 자원을 교착상태가 해결될 때까지 다른 프로세스에 할당

 