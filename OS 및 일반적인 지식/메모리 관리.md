# 메모리 관리 🧐

### 메모리 종류 💾

1. 메인 메모리: 명령어 집합에 의해 정의된 메모리로서 실행될 프로그램과 데이터가 머무는 장소
2. 가상 메모리: 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식
3. 캐시 메모리: 주기억장치와 CPU사이에 위치하며, 자주 사용하는 프로그램과 데이터를 기억

: 다중 프로그래밍에서 주기억 장치를 여러 프로그램이 공유하기 때문에 관리 기법이 필요

<br>

### 주소 바인딩 😗

**"메모리 어디에 적재할 것이냐"**

: 프로그램의 명령어와 데이터를 기억 장치 주소 공간으로 할당하는 과정.

<br>

기억 공간에서의 바인딩 시점

1. 컴파일 시간 바인딩: 메모리 저장 위치 고정
2. 적재 시간 바인딩: 메모리에 적재되는 시기에 위치가 결정
3. 실행시간 바인딩: 실행 중 MMU에 의해 결정. 위치 변경 가능

<br>

논리 주소: CPU가 생성하는 주소

물리 주소: 기억 장치에 나타나는 주소

<br>

### 기억장치 관리기(MMU) 🐱‍💻

**MMU** (Memory Management Unit) ⭐

- 논리 주소(가상 주소)의 물리 주소 사상을 수행하는 하드웨어
- 가상메모리와 관련됨
- 실행시간 바인딩에서 사용

![image](https://user-images.githubusercontent.com/62419307/89663140-139d4700-d910-11ea-95b1-d99b8168ad37.png)

<br>

### 중첩 (Overlays) 🐘

일명 냉장고에 코끼리 넣기.

- 허용된 메모리 크기보다 큰 프로그램을 실행할 때의 해결법
- 실행하려는 프로그램이 메모리보다 클 때는 당장 필요하지 않은 프로그램의 일부는 중첩 (오버레이)으로 설정 가능. 
- 하나의 프로그램을 여러 개의 조각으로 분할한 후, 필요한 조각을 순서대로 주기억장치에 적재하여 프로그램을 실행
- 오버레이 영역: 필요에 따라서 프로그램을 적재하여 실행하고, 불필요하면 다른 프로그램으로 교체하는 부분

<br>

### 교체 (Swapping) 🙋‍♀️

프로세서 할당이 끝나고 수행 완료 된 프로세스는 보조기억장치로 보내고(스왑 아웃), 새롭게 시작하는 프로세스는 메모리에 적재 (스왑 인). **프로세스는 메모리에 있어야 수행되므로 일시적으로 디스크로 이동했다가 메모리로 되돌아와 다시 수행 가능**

고려사항

- 교체 시간: 디스크 성능에 의해 좌우
- 메모리 사용량: 메모리량이 교체 시간에 영향
- 교체 대상: 아무 일도 하지 않는 프로세스

![image](https://user-images.githubusercontent.com/62419307/89663326-5bbc6980-d910-11ea-9a96-190f49cf2c8d.png)

<br>

### 메모리 관리 기법 분류 🤗

- #### 연속 메모리 할당 방식

  - 프로그램(프로세스)를 적재하는 과정에서 연속적으로 메모리를 할당

  - 메모리를 분할하여 여러 개의 프로그램을 수용하여 다중 프로그래밍 가능

  - 메모리 분할: 운영체제 부분과 사용자 부분을 나눔

    

- #### 고정 분할

  - 기억 장치를 고정된 크기로 분할
  - 다중 프로그래밍 정도는 분할의 수에 의해 제한
  - 운영체제는 분할 간 보호: 재배치 레지스터에 의한 지원

  

- #### 가변 분할

  - 고정된 경계를 없애고 각 작업이 필요한 만큼 메모리를 할당
  - 메모리 배치 기법
    - 최초 적합 기법: 사용 가능 공간에서 충분히 큰 첫 번째 공백 분할 공간에 할당
    - 최상 적합 기법: 들어갈 수 있는 공간들 중에서 가장 작은 크기의 공간에 할당
    - 최악 적합 기법: 작업을 가장 큰 사용 가능 공간에 할당
  - 단편화
    - 외부 단편화: 메모리 할당 요청을 만족할 수 있는 여러 조각들로 나누어진 가용 기억 공간 → 압축으로 해결 가능
    - 내부 단편화: 할당된 기억 공간이 요청된 기억 공간보다 더 클 때 남는 부분
  
  ✅ 감이 잘 오지 않는다면? [참고하기!](https://jhnyang.tistory.com/264)

<br>

### 버디 시스템 (Buddy System) 👭

- 커널 메모리 할당에 적용
- 동작 원리
  1. 요청된 크기가 버퍼보다 작으면 버퍼를 동일한 크기로 2개의 버디로 나눔
  2. 가능할 때마다 인접한 자유 버퍼들을 합치는 과정을 반복

![image](https://user-images.githubusercontent.com/62419307/89661669-efd90180-d90d-11ea-90a9-203f75a24c3d.png)

<br>

### 페이징 기법 (Paging) 📖

- 분산 메모리 할당 방식
- 프로그램을 페이지라는 고정 크기 단위로 나눠 분산 적재
- 메모리 영역도 프레임이라는 고정 크기로 분리하여 관리
- 장점
  - 공유 페이지의 이용
  - 외부 단편화 제거 (내부 단편화는 발생)
  - 압축 기능 제거
- 단점
  - 페이지 사상을 위한 HW 준비로 가격 상승
  - 속도 저하

[잘 모르겠으면 참조!](https://jhnyang.tistory.com/290?category=815411)

<br>

### 세그멘테이션 기법 (Segmentation) 🧩

- 사용자 관점을 지원하는 기억 장치 관리 방법
- 세그먼트: 메모리의 가변적인 단위
- 프로그램은 세그먼트들의 집합
- 세그멘테이션의 보호와 공유
  - 보호
    - 명령어로 구성된 세그먼트는 읽기 또는 수행 전용으로 정의
    - 세그먼트 테이블의 각 항목에 대한 보호 비트를 추가
  - 공유
    - 프로그램 코드 및 데이터의 공유

<br>

![](https://user-images.githubusercontent.com/62419307/89662523-2d8a5a00-d90f-11ea-966b-0e8d23b25b9e.png)

<br>

### 페이징과 세그멘테이션 비교 👀

| 비교                                     | 페이징 | 세그멘테이션 |
| ---------------------------------------- | ------ | ------------ |
| 프로그래머의 기술 인식                   | N      | Y            |
| 선형 주소 공간                           | 1      | 많음         |
| 물리적 주소를 초과하는 총 주소 공간      | Y      | Y            |
| 프로시저와 데이터 분리, 보호 여부        | N      | Y            |
| 수용할 수 있는 테이블 크기가 심하게 변화 | N      | Y            |
| 사용자 공유가 용이                       | N      | Y            |

<br>

### 페이지 부재 오류 (Page Fault) 😕

지정된 프레임 페이지가 메모리에 적재되지 않은 경우, 페이지 교체 동안에 CPU는 다른 프로그램 실행

![image](https://user-images.githubusercontent.com/62419307/89665883-56f9b480-d914-11ea-96f1-0f9058cfd9fd.png)

<br>

### 페이지 교체 알고리즘😏

- #### 선입 선출 알고리즘 (FIFO)

  - 가장 오래된 페이지가 교체되도록 선택

  - 가장 간단한 페이지 교체 알고리즘

  - FIFO 큐 이용

  - 문제점 - 벨레디의 변이: 할당되는 프레임의 수가 증가해도 페이지 부재율이 증가하는 현상

    

- #### 최적 교체 알고리즘 (Optimal)

  - 앞으로 가장 오래 사용되지 않을 페이지 교체

  - 모든 알고리즘 중에서 가장 낮은 페이지 부재율을 보장

  - 현실적인 구현이 어려우며, 비교 연구를 위해 주로 사용됨

    

- #### LRU 알고리즘 (Least Recently Used)

  - 가장 오랫동안 사용하지 않은 페이지 교체

  - 가까운 미래의 근삿값으로 가장 최근의 과거를 사용

  - 마지막 사용 시간을 기록하기 위하 하드웨어 지원이 필요

    
    
    