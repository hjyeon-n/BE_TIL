# CPU 스케줄링 ⏰

### 스케줄링이란? 😮

- 다중 프로그래밍
- 프로세스들을 프로세서에 할당하는 일련의 과정
  - 각 프로세스의 실행 여부를 결정하므로 시스템 성능에 영향을 미침
  - 시스템의 작업 처리 능력을 향상, 작업의 응답 시간을 최소화
- 프로세스 실행은 CPU 실행과 입출력 대기의 순환으로 구성

<br>

### 스케줄러의 종류 🤔

- 장기 (작업) 스케줄러: 프로세스의 생성 과정에서 프로세스의 준비 상태에 무엇을 추가할지 결정
- 중기 스케줄러: 작업의 혼합 개선 또는 메모리 가용량 증가를 위해 교체 작업
- 단기 (CPU) 스케줄러: 미리 정해진 알고리즘에 따라 실행할 프로세스를 선택

![image](https://user-images.githubusercontent.com/62419307/89497258-f163d600-d7f6-11ea-9ad4-5bfda50b590a.png)

<br>

### 비선점 스케줄링과 선점 스케줄링 😏

- **비선점 스케줄링 (NonPreemptive Scheduling)** 
  - 다른 프로세스에 할당된 **자원을 빼앗을 수 없는 스케줄링**.
  - 우선순위가 높은 작업들이 중간에 입력되어도 대기 중인 작업들은 영향을 받지 않기 때문에 응답 시간 예측이 쉽다.
- **선점 스케줄링 (Preemptive Scheduling)**
  - 현재 실행 중인 **프로세스를 인터럽트 할 수 있거나 준비 상태로 이동시킬 수 있는 스케줄링**.
  - 우선순위가 높은 프로세스들이 긴급한 처리를 요청할 때 유용하다.
  - 선점을 효과적으로 하기 위해 메인 메모리에 많은 프로세스들이 저장되어 있어야 하므로 많은 오버헤드를 초래한다.

<br>

### 스케줄링 알고리즘 비교 기준✅

- CPU 이용률 (utilization)
- 처리량 또는 작업 처리율 (throughput): 단위 시간당 완료된 작업 수
- 총처리 시간 또는 반환 시간 (turnaround time): 진입한 시간과 완료한 시간의 차이
- 대기시간 (waiting time): 준비 큐에서 대기하는 시간
- 응답 시간 또는 반응 시간 (response time): 요청 제출 후 첫 번째 응답이 나올 때까지의 시간

![image](https://user-images.githubusercontent.com/62419307/89499501-19553880-d7fb-11ea-9827-0bd31c704885.png)

<br>

### 스케줄링 알고리즘 😛

- #### 선입 선처리 스케줄링 (FCFS)

  - 프로세서를 요구 순서대로 할당 (First-Come-First-Served)
  - 선입선출(FIFO) 큐로 구현
  - 일괄처리 시스템에는 효율적, 대화식 시스템에서는 사용자의 빠른 응답 요구에 부적합

  ![image](https://user-images.githubusercontent.com/62419307/89502343-d47fd080-d7ff-11ea-8312-c8198d282516.png)

  <br>

- #### 최단 작업 우선 스케줄링 (SJF)

  - CPU 버스트 시간이 가장 짧은 작업에 CPU를 할당 (동일한 실행시간이면 FCFS)
  - 주어진 작업 집합에 대해 평균 대기시간을 최소화하는 알고리즘
  - 실행을 해 봐야 알기 때문에 실행 시간 길이 예측이 힘듦
  - **선점 또는 비선점이 모두 가능**

![image](https://user-images.githubusercontent.com/62419307/89502405-eb262780-d7ff-11ea-9a65-f5d50ee2cc8c.png)

<br>

- #### 우선순위 스케줄링 (Priority)

  - 최고 우선순위의 프로세스에 CPU를 할당

  - 최단 작업 우선 알고리즘은 우선순위 알고리즘에 속함

  - 선점 또는 비선점에 모두 적용 가능

  - 우선 순위가 높은 프로세스들이 계속 들어오면 우선순위가 낮은 프로세스들은 무한정 대기

    → 기아 상태 발생 가능 

    ✔ **해결방법: 에이징** (오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킴)

  ![image](https://user-images.githubusercontent.com/62419307/89502515-1446b800-d800-11ea-99fc-1db3a6b09c82.png)

<br>

- #### 라운드 로빈 스케줄링 (Round Robin)

  - 시분할 시스템을 위해 설계

  - 규정 시간량이 지나면 인터럽트가 발생되며 문맥 교환 수행

  - 선점 알고리즘

  - 성능은 규정 시간량의 크기에 영향을 받음

    - 규정 시간량이 아주 클 경우: 선입 선처리 방식으로 변함, 작업 시간이 긴 프로세스들로 인해 짧은 프로세스들이 대기
    - 규정 시간량이 매우 작은 경우: 문맥 교환이 빈번하게 일어나 프로세서 유휴시간이 증가

  - 반환 시간도 규정 시간량 크기에 영향을 받음

  - 반환 시간이 규정 시간량의 크기에 항상 반비례하지는 않음

    

    ![image](https://user-images.githubusercontent.com/62419307/89502175-88cd2700-d7ff-11ea-8b10-712b9a5ff4e9.png)

    <br>

- #### 다단계 큐 스케줄링 (Multilevel Queue)

  - 준비 상태 큐를 종류별로 여러 단계로 분할한 뒤, 각 큐에 독자적인 스케줄링 알고리즘을 가지게 함
  - 큐 사이에도 스케줄링이 있는데, 이는 고정된 우선순위의 선점식 스케줄링. 즉, 줄 하나를 끝내야 다른 줄을 처리

  

  ![image](https://user-images.githubusercontent.com/62419307/89503268-44db2180-d801-11ea-8db9-3872f1eb5397.png)

  <br>

- #### 다단계 피드백 큐 스케줄링 (Multilevel Queue with Feedback)

  - **가장 일반적인 기법이며, 가장 복잡한 알고리즘**

  - 작업이 큐 사이를 이동할 수 있음

    - 프로세서 기간이 너무 길면 낮은 단계 큐로 이동

  - 기아 상태 예방을 위한 에이징 방법을 활용

    - 특정 큐에서 오래 기다린 프로세스를 우선순위가 높은 큐로 이동시킴
    - 프로세서 점유 시간이 긴 작업을 우선순위가 낮은 큐로 이동

    

  ![image](https://user-images.githubusercontent.com/62419307/89503790-085bf580-d802-11ea-8c5e-9a543310d353.png)

  <br>

- #### HRN 스케줄링

  - SJF 기법의 약점인 긴 작업과 짧은 작업 간의 불평등을 보완한 기법 (에이징 기법을 구현)
  - 비선점 스케줄링
  - 가변적 우선순위: 서비스 받을 시간 + 서비스를 기다린 시간

  

  ![image](https://user-images.githubusercontent.com/62419307/89504086-73a5c780-d802-11ea-943b-825d78d31cc7.png)

  <br>

- #### 다중 처리기 스케줄링

  - 다중 프로세서 시스템의 스케줄링
  - 전역 큐를 이용한 부하 공유

  <br>

- #### 실시간 스케줄링

  - 프로세스 수행이 데드라인 이전에 완료 보장
  - 동작 이전에 데드라인 만족도가 예측 가능해야 함
  - 최대 수행 완료 시간이 데드라인을 만족해야 함