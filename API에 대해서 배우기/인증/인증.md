# 인증 🙆‍♀️

1. **식별(identification)** : 식별은 시스템에게 주체의 식별자를 요청하는 과정으로 각 시스템의 사용자들은 시스템이 식별할 수 있는 유일한 식별자(ID)를 갖는다. 개인 식별자는 반드시 유일한 것을 사용해야 하고, 공유해서는 안 된다.
2. **인증(authentication)** : 임의의 정보에 접근할 수 있는 주체의 능력이나 주체의 자격을 검증하는 단계이다. 이는 시스템의 부당한 사용이나 정보의 부당한 전송을 방지한다.
3. **인가(authorization)** : 사용자, 프로그램, 프로세스에게 허가한 권한을 의미한다. 권한을 부여한다는 것은 누구에게 무엇을 할 수 있거나 가질 수 있는 권한을 부여한다는 것이다.
4. **책임 추적성(accountability)** : 멀티태스킹이 지원되는 네트워크 환경에서 누가, 언제, 어떤 행동을 하였는지 기록하여 필요시 그 행위자를 추적 가능하게 하여 책임 소재를 명확하게 할 수 있는 기반이다.

<br>

### 기본적인 인증 👾

- HTTP에서 작동하는 인증 방식의 일종
- 사용 및 구현이 간편하여 여러 소프트웨어들이 이 기능을 지원한다.
- 사용자명과 패스워드를 base64 encode하여 헤더에 포함시켜 송신한다.
- 패킷 도청에는 취약하다.

✔ 높은 수준의 보안이 필요한 경우에는 다른 인증수단(예: OAuth, mTLS)을 사용하는 것이 바람직하다.

<br>

### cookie/session 인증 🍪

**여기서 잠깐🖐 세션은 뭐고, 쿠키는 뭐야❓**

1. 세션 : 서버에서 가지고 있는 정보
2. 쿠키: 사용자에게 발급된 세션을 열기 위한 열쇠(SESSION ID)를 의미

<br>

쿠키만으로 인증을 사용한다는 말은 서버의 자원은 사용하지 않는다는 것이며, 이는 즉 클라이언트가 인증 정보를 책임지게 된다는 의미다. 그렇게 되면 기본적인 인증 방식처럼 HTTP 요청을 탈취당할 경우 보안 위험이 존재한다. 따라서 보안과는 상관없는 단순히 장바구니나 자동 로그인 설정 같은 경우에는 유용하게 쓰인다.

✔ 결과적으로 인증의 책임을 서버가 지게하기 위해 세션을 사용하는 것! 사용자(클라이언트)는 쿠키를 이용하고, 서버에서는 쿠키를 받아 세션의 정보를 접근하는 방식으로 인증을 한다.

![image](https://user-images.githubusercontent.com/62419307/90213028-c3524780-de2f-11ea-8f77-226b2e4adb85.png)

1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 DB를 통해 사용자를 확인한다.
3. 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장한 후, 이와 연결되는 세션ID를 발행한다.
4. 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장을 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다.
5. 서버에서는 쿠키를 받아 세션 저장소에서 대조를 한 후 대응되는 정보를 가져온다.
6. 인증이 완료되고 서버는 사용자에 맞는 데이터를 전송한다.

<br>

**장점** 😊

- 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 가지고 있지 않다.(중요 정보는 서버 세션에)
- 사용자 A는 1번, 사용자 B는 2번 이런 방식으로 고유의 ID값을 발급받게 된다. 따라서 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이하다.

<br>

 **단점** 🙁

- 만약 A 사용자의 HTTP 요청을 B 사용자(해커)가 가로챘다면 그 안에 들어있는 쿠키도 충분히 훔칠 수 있다. 그리고 B 사용자는 그 훔친 쿠키를 이용해 HTTP 요청을 보내면 서버의 세션 저장소에서는 A 사용자로 오인해 정보를 전송하게 된다. (세션 하이재킹)

  해결책 ✨

  1. HTTPS를 사용해 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 한다. 
  2. 세션에 유효시간을 넣어준다. 

- 서버의 세션저장소로 인해, 서버에서 추가적인 저장 공간을 필요로 하게되고 부하도 높아진다.

<br>

### 토큰 인증 😎

**JWT**(Json Web Token): 인증에 필요한 정보들을 암호화시킨 토큰

✔ 세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 된다.

<br>

#### 토큰을 만들기 위해서 뭐가 필요해? 🧙‍♀️

- Header : 암호화할 방식(alg), 타입(type) 
- Payload : 서버에서 보낼 데이터가 들어간다. 일반적으로 유저의 고유 ID값, 유효기간.
- Verify Signature : Base64 방식으로 인코딩한 Header, payload, SECRET KEY를 더한 후 서명된다.

✔ 최종적인 결과 : **Encoded Header + "." + Encoded Payload + "." + Verify Signature**

Header, Payload는 인코딩될 뿐(16진수로 변경) 따로 암호화되지 않는다. 따라서 JWT 토큰에서 Header, Payload는 누구나 디코딩하여 확인할 수 있다. 즉, Payload에 유저의 중요한 정보(비밀번호)가 들어가면 쉽게 노출될 수 있다. 하지만 Verify Signature는 SECRET KEY를 알지 못하면 복호화할 수 없다. 

<br>

#### 어떻게 확인하지? 🤔

A 사용자가 토큰을 조작하여 B 사용자의 데이터를 훔쳐보고 싶다고 가정하자. 

1. payload에 있던 A의 ID를 B의 ID로 바꿔서 다시 인코딩한 후 토큰을 서버로 전송한다. 
2. 그러면 서버는 처음에 암호화된 Verify Signature를 검사한다. 
3. 여기서 payload는 B 사용자의 정보가 들어가 있으나, Verify Signature는 A의 Payload를 기반으로 암호화되었기 때문에 유효하지 않는 토큰으로 간주하게 된다. 

✔ 따라서, A 사용자는 SECRET KEY를 알지 못하는 이상 토큰을 조작할 수 없다는 걸 확인할 수 있다.

<br>

![image](https://user-images.githubusercontent.com/62419307/90214549-d49d5300-de33-11ea-9ea0-66a505a666ba.png)

1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 사용자를 확인 한다.
3.  사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣는다.
4. JWT 토큰의 유효기간 설정
5.  암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급한다.
6. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
7. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인한다.
8. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다. 

<br>

#### 세션/쿠키 방식이랑 뭐가 달라? 👀

**세션/쿠키는 세션 저장소에 유저의 정보**를 넣는 반면, **JWT는 토큰 안에 유저의 정보들을 넣는다는 점**이다. 물론 클라이언트 입장에서는 HTTP 헤더에 세션ID나 토큰을 실어서 보내준다는 점에서는 동일하지만 서버 측에서는 인증을 위해 암호화를 하냐, 별도의 저장소를 이용하냐는 차이가 발생하게 된다.

<br>

**장점**😊

- 간편하다. 세션/쿠키는 별도의 저장소의 관리가 필요하다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없다. 이는 Stateless 한 서버를 만드는 입장에서는 큰 강점이 된다. 여기서 Stateless는 어떠한 별도의 저장소도 사용하지 않는, 즉 상태를 저장하지 않는 것을 의미하며, 이는 서버를 확장하거나 유지, 보수하는데 유리하다.
- 확장성이 뛰어나다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 한다. 이에 선택적으로 이름이나 이메일 등을 받을 수 있는 권한도 받을 수 있다.

<br>

 **단점** 🙁

- 이미 발급된 JWT에 대해서는 돌이킬 수 없다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 된다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능하다. 

  해결책 ✨

  기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급한다.

- Payload는 따로 암호화되지 않기 때문에 Payload 정보가 제한적이다.

- 세션/쿠키 방식에 비해 JWT의 길이가 길다. 따라서 인증이 필요한 요청이 많아질수록 서버의 자원낭비가 발생하게 된다.

<br>

[참고1](https://m.blog.naver.com/PostView.nhn?blogId=wnrjsxo&logNo=221727680845&proxyReferer=https:%2F%2Fwww.google.com%2F)

[참고2](https://zetawiki.com/wiki/HTTP_%EA%B8%B0%EB%B3%B8_%EC%9D%B8%EC%A6%9D)

[참고3](https://tansfil.tistory.com/58)