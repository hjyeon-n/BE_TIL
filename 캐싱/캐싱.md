# 캐싱👻

캐시는 캐시의 접근 시간에 비해 데이터를 접근하는 시간이 오래 걸리는 경우 혹은 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다. 따라서 캐싱은 높은 성능의 웹 애플리케이션과 웹 서버를 더 쉽게 만들어주는 역할을 한다.

<br>

이제 우유를 예시로 들어, 캐싱에 대해 설명해 보자! 😎🥛

<br>

### 캐싱이란 뭘까? 🤔

우선, 우유 농장을 생각해 보자. 만약 **냉장고(캐시)가 없으면 우유는 금방 상해버리기 때문에** 마을에 내다 팔고 싶어도 아주 제한된 시간 안에 팔 수밖에 없게 된다. 그런데 너무 많은 사람들이 우유를 사러 온다면 일단 일부만 준 다음에 나머지는 내일 찾으러 오라고 해야 할 것이다. 배급 가능한 양에 한계가 있기 때문에 소를 더 들여놓을 수도 없다. 여러분의 마을에 있는 사람들만 우유를 구입하고 있기 때문에 확장 가능한 범위가 명확하다.

이렇게 캐싱을 하지 않은 상태에서, 서버의 컴퓨팅 파워는 한계가 있다. 캐싱은 주로 아래와 같은 정적 자료(static assets)들을 불러오는데 사용된다.

- 이미지 파일
- CSS 파일
- HTML 파일
- 자바스크립트 파일

서버는 기본적으로 매 요청마다 새로운 응답을 돌려주어야 한다. 하지만 실제로 페이지를 불러오기 위한 요청은 하나가 아니라 위의 4 가지 카테고리에 있는 파일들을 각각 요청하는 경우가 많다. 거대한 이미지 파일을 처리하는 데 시간이 오래 걸린다면 서버는 전세계에서 몰려드는 수많은 사용자들 덕에 버벅이게 된다. 결과적으로 사용자들은 페이지가 로딩될 때까지 아주 오랜 시간 기다려야 할 수도 있다.

![image](https://user-images.githubusercontent.com/62419307/90308252-eefd2c80-df18-11ea-8a9f-0fffed72d101.png)

<br>

### 서버 사이드 캐싱 ❄

농장을 성공적으로 운영하려면 어떻게 해야 할까? 바로 **냉장고가 있는 슈퍼마켓(서버 사이드 캐시)을 세우면 된다!😲**

이렇게 하면 사람들은 우유를 마시기 위해 농장에 직접 올 일도 없으며, 우유도 한 번 생산하고 2 주정도는 거뜬히 보관할 수 있게 된다.

이젠 그저 매일 소가 알맞은 양의 우유를 만들어내도록 관리하면 된다.  언제나 슈퍼마켓 냉장고 안에 우유가 들어있기 때문에 마을 주변에 있는 모든 주민들도 우유를 살 수 있게 된다.

![image](https://user-images.githubusercontent.com/62419307/90308364-fec94080-df19-11ea-8593-88a7fc06029a.png)

![image](https://user-images.githubusercontent.com/62419307/90308381-199bb500-df1a-11ea-8c8b-f46b57e4a5b8.png)

<br>

슈퍼마켓처럼 서버 사이드 캐시는 일반적인 요청을 바로 처리하여 컨텐츠를 더 빠르고 안정적으로 전달할 수 있다.

**캐싱 프록시** **(Caching proxy)**는 정적 파일을 저장해두고 이 파일들을 찾는 요청에 응답하는 서버이다. 이를 통해 *공통된* 요청을 가로채서 빠르게 응답하게 된다. 이렇게 메인 웹 서버에 들어가는 부담을 줄일 수 있다.

그러면,

1. **“공통된/일반적인”** 요청이라는 걸 어떻게 정의하지?
2. 프록시 서버는 캐시를 얼마나 유지할까?

**신선도**라는 개념을 기억해 보자!! 😏 캐싱 프록시는 서로 다른 시간에 캐싱된 각각 다른 파일을 가지고 있으며, 언제까지 이 파일을 전달해야할지 지정해야 한다. 이 부분은 **캐싱 정책** **(Caching policy)**에 달려있다.

이 부분도 슈퍼마켓에 들어있는 우유에 비유할 수 있다🥛. 슈퍼마켓 관리자는 우유를 얼마나 오래 보관하고 있다가 버릴 지 결정해야 한다. 캐싱 프록시는 **캐시 적중률** **(cache hit ratio, 캐싱 서버가 전달할 수 있는 컨텐츠의 비율)**이라는 개념을 통해 얼마나 성공적으로 캐시들이 전달되는지 측정한다.

<br>

### CDN 🌏

하지만 아직까지는 슈퍼마켓 범위의 바깥에 있는 사람들에게는 우유를 판매할 수 없다. 판매량을 늘리고 싶다면 더 많은 상점에 우유를 납품해야 한다.

그래서 더 많은 슈퍼마켓에 우유를 공급하여 더 넓은 지리적 범위에 위치한 사용자들을 만족시킬 수 있게 되었다. 이 형태는 **CDN** **(content delivery network)**과 유사하다. CDN 은 전 세계에 위치한 프록시 서버(위에서 이야기한 캐싱 프록시)의 묶음을 말한다.

일반 사용자들은 보통 인터넷 속도가 빠르니까 대부분의 사이트가 빨리 로딩된다고 느낄 수 있다. 하지만 실제로는 CDN 이 정적 파일을 빠른 속도로 전달해주니까 빠른 속도를 느낄 수 있는 것! 😉

🗨 만약 이용자가 서울에 있고 캐나다 벤쿠버에 위치한 서버에 캐시된 파일을 불러오려는 경우, 처음 시작된 신호가 수천 마일의 케이블을 타고 오느라 약간의 지연을 느낄 수 있다. 만약 서울에 있는 프록시에 접근할 수 있다면 훨씬 빠르게 파일을 불러올 수 있다.

![image](https://user-images.githubusercontent.com/62419307/90308564-6f249180-df1b-11ea-959f-c44e5b825305.png)

![image](https://user-images.githubusercontent.com/62419307/90308569-7c418080-df1b-11ea-9698-94284f3cfcc1.png)

<br>

따라서 메인 서버는 정적 자료 사본을 CDN 네트워크 내의 프록시 서버들에게 전송할 수 있으며 더 이상 자료가 **신선하지 않을 때까지** 그 지역의 요청을 신속하게 처리 할 수 있게 된다. 일반적인 CDN 제공 업체에는 Rackspace, Akamai 및 Amazon Web Services 가 있다.

<br>

### 브라우저 캐싱 💨

이제 외국에 있는 사람들도 여러분의 농장에서 만들어진 시원한 우유를 집에서 마실 수 있게 되었다. 하지만 아직 사람들은 집에 우유를 보관할 방법이 없다.😖 

해결책은⁉ **냉장고를 사면 된다**‼

냉장고를 사용하면 우유를 사서 집에 저장할 수 있고, 슈퍼마켓에 자주 왔다갔다할 필요가 없게된다. 캐싱 용어로 말하면 클라이언트에도 정적 자료를 저장할 수 있다는 것이다. 클라이언트라 함은 브라우저로 접속한 컴퓨터를 말한다.

이 방식은 Facebook 이나 Amazon 같이 자주 접속하는 사이트에 아주 효과적인 방식이다. 엄청난 양의 요청을 줄일 수 있기 때문에 회사들의 서버 비용을 줄이는데도 도움이 된다.

![image](https://user-images.githubusercontent.com/62419307/90308664-4355db80-df1c-11ea-907f-747fe866e2ef.png)

 ![image](https://user-images.githubusercontent.com/62419307/90308730-f292b280-df1c-11ea-82ff-37217c2fcd8a.png)

<br>

단, 우리는 **마법처럼** 집에 있는 냉장고에 우유가 뿅 하고 나타나는 상황에 대해 이야기하는게 아니다.🧙‍♀️ 사용자들은 여전히 실제 서버나 프록시 서버로 전달되는 요청을 보내야 한다. (즉, 우유를 사와야 한다.) 그리고 나서야 일부 파일을 로컬 머신에 저장할 수 있게 된다.

어떻게 브라우저는 언제쯤 새 파일을 서버로부터 받아올지 알고 있을까? 🧐

우유 생산자들이 우유곽에 적어둔 유통기한처럼, 서버는 HTTP 응답 헤더에 일부 식별자를 추가한다. 일부 다른 방법을 사용할 경우 서버와 통신해서 캐시의 유효성을 확인하기도 한다.

![image](https://user-images.githubusercontent.com/62419307/90308727-e4449680-df1c-11ea-9f8a-df6c841c4f2d.png)

<br>

### Redis 🐱

메모리 기반의 **키-값 구조 데이터 관리 시스템**이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장하는 **비 관계형 데이터베이스**이다. 

Redis에서는 다양한 데이터 구조를 제공한다.

1. Lists
2. Sets
3. Strings 
4. Sorted Sets 
5. Hashses

이렇게 다양한 데이터 구조를 지원하기 때문에 Redis는 **캐시 데이터 저장, 인증 토큰 저장, Ranking Board** 등으로 주로 사용된다.

<br>

### Memcached 🐶

Facebook, Twitter 및 YouTube와 같은 클라우드 및 웹 서비스 제공 회사에서 사용하는 key-value 메모리 캐시로, 웹 데이터를 소비자에게 서비스하는 데 있어 지연 시간을 줄이고 데이터베이스 및 컴퓨팅 서버에 대한 증설을 줄여주게 한다. Latency를 줄이는 것 외에도 memcached의 확장성 있는 아키텍처 (scale-out) 는 memcached 서버를 간단하게 추가만 하여 처리량을 높일 수 있다. 

<br>

### Redis와 Memcached의 공통점 🤸‍♀️

- **1ms 이하의 응답대기시간**

  : 데이터를 메모리에 저장하기 때문에, 디스크 기반의 데이터베이스보다 빠르게 데이터를 읽을 수 있다.

- **개발의 용이성**

  : 문법적으로 사용하기 쉽고, 개발코드 양 또한 적다.

- **데이터 파티셔닝**

  : 데이터를 여러 노드에 분산하여 저장시킬 수 있다. 따라서 수요가 증가할 때 더 많은 데이터를 효과적으로 처리하기 위하여 스케일아웃이 가능하다.

- **다양한 프로그래밍 언어 지원**

  여러 개발언어를 지원한다. Java, Python, C, C++, C#, JavaScript, Node.Js, Ruby, Go  등의 언어를 지원한다.

<br>

### Redis와 Memcached의 차이점 🤸‍♂️

#### Redis만의 특징

- 다양한 데이터 구조
- snapshot
- 복제
- 트랜잭션
- Pub/Sub messaging
- 루아 스크립트 지원
- 위치 기반 데이터 타입 지원

<br>

#### Memcached만의 특징

**멀티스레드를 지원**하기 때문에 멀티프로세스코어를 사용할 수 있다. 따라서 스케일업을 통하여 더욱 많은 작업처리를 할 수 있다.

<br>

[참고1](https://rinae.dev/posts/web-caching-explained-by-buying-milk-kr)

[참고2](https://brunch.co.kr/@jehovah/20)

[참고3](https://d2.naver.com/helloworld/151047)

[참고4](https://medium.com/@chrisjune_13837/redis-vs-memcached-10e796ddd717)